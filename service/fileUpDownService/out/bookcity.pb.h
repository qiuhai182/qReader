// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bookcity.proto

#ifndef PROTOBUF_INCLUDED_bookcity_2eproto
#define PROTOBUF_INCLUDED_bookcity_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_bookcity_2eproto 

namespace protobuf_bookcity_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_bookcity_2eproto
namespace bookCityService {
class adInfo;
class adInfoDefaultTypeInternal;
extern adInfoDefaultTypeInternal _adInfo_default_instance_;
class adsReq;
class adsReqDefaultTypeInternal;
extern adsReqDefaultTypeInternal _adsReq_default_instance_;
class adsRes;
class adsResDefaultTypeInternal;
extern adsResDefaultTypeInternal _adsRes_default_instance_;
class boocomCombinekInfo;
class boocomCombinekInfoDefaultTypeInternal;
extern boocomCombinekInfoDefaultTypeInternal _boocomCombinekInfo_default_instance_;
class bookBaseInfo;
class bookBaseInfoDefaultTypeInternal;
extern bookBaseInfoDefaultTypeInternal _bookBaseInfo_default_instance_;
class bookDownInfo;
class bookDownInfoDefaultTypeInternal;
extern bookDownInfoDefaultTypeInternal _bookDownInfo_default_instance_;
class bookGradeInfo;
class bookGradeInfoDefaultTypeInternal;
extern bookGradeInfoDefaultTypeInternal _bookGradeInfo_default_instance_;
class bookMarkItem;
class bookMarkItemDefaultTypeInternal;
extern bookMarkItemDefaultTypeInternal _bookMarkItem_default_instance_;
class booksRespList;
class booksRespListDefaultTypeInternal;
extern booksRespListDefaultTypeInternal _booksRespList_default_instance_;
class browseBookReq;
class browseBookReqDefaultTypeInternal;
extern browseBookReqDefaultTypeInternal _browseBookReq_default_instance_;
class browseBookRes;
class browseBookResDefaultTypeInternal;
extern browseBookResDefaultTypeInternal _browseBookRes_default_instance_;
class delBookReq;
class delBookReqDefaultTypeInternal;
extern delBookReqDefaultTypeInternal _delBookReq_default_instance_;
class fuzzySearchRequest;
class fuzzySearchRequestDefaultTypeInternal;
extern fuzzySearchRequestDefaultTypeInternal _fuzzySearchRequest_default_instance_;
class getAllBookInfoReq;
class getAllBookInfoReqDefaultTypeInternal;
extern getAllBookInfoReqDefaultTypeInternal _getAllBookInfoReq_default_instance_;
class getBookTypeReq;
class getBookTypeReqDefaultTypeInternal;
extern getBookTypeReqDefaultTypeInternal _getBookTypeReq_default_instance_;
class mostlySearchRes;
class mostlySearchResDefaultTypeInternal;
extern mostlySearchResDefaultTypeInternal _mostlySearchRes_default_instance_;
class mostlybooks;
class mostlybooksDefaultTypeInternal;
extern mostlybooksDefaultTypeInternal _mostlybooks_default_instance_;
class recommendBookReq;
class recommendBookReqDefaultTypeInternal;
extern recommendBookReqDefaultTypeInternal _recommendBookReq_default_instance_;
class recommendBookRes;
class recommendBookResDefaultTypeInternal;
extern recommendBookResDefaultTypeInternal _recommendBookRes_default_instance_;
class searchBookReq;
class searchBookReqDefaultTypeInternal;
extern searchBookReqDefaultTypeInternal _searchBookReq_default_instance_;
class universalBlankReq;
class universalBlankReqDefaultTypeInternal;
extern universalBlankReqDefaultTypeInternal _universalBlankReq_default_instance_;
class updateBookBaseInfo;
class updateBookBaseInfoDefaultTypeInternal;
extern updateBookBaseInfoDefaultTypeInternal _updateBookBaseInfo_default_instance_;
}  // namespace bookCityService
namespace google {
namespace protobuf {
template<> ::bookCityService::adInfo* Arena::CreateMaybeMessage<::bookCityService::adInfo>(Arena*);
template<> ::bookCityService::adsReq* Arena::CreateMaybeMessage<::bookCityService::adsReq>(Arena*);
template<> ::bookCityService::adsRes* Arena::CreateMaybeMessage<::bookCityService::adsRes>(Arena*);
template<> ::bookCityService::boocomCombinekInfo* Arena::CreateMaybeMessage<::bookCityService::boocomCombinekInfo>(Arena*);
template<> ::bookCityService::bookBaseInfo* Arena::CreateMaybeMessage<::bookCityService::bookBaseInfo>(Arena*);
template<> ::bookCityService::bookDownInfo* Arena::CreateMaybeMessage<::bookCityService::bookDownInfo>(Arena*);
template<> ::bookCityService::bookGradeInfo* Arena::CreateMaybeMessage<::bookCityService::bookGradeInfo>(Arena*);
template<> ::bookCityService::bookMarkItem* Arena::CreateMaybeMessage<::bookCityService::bookMarkItem>(Arena*);
template<> ::bookCityService::booksRespList* Arena::CreateMaybeMessage<::bookCityService::booksRespList>(Arena*);
template<> ::bookCityService::browseBookReq* Arena::CreateMaybeMessage<::bookCityService::browseBookReq>(Arena*);
template<> ::bookCityService::browseBookRes* Arena::CreateMaybeMessage<::bookCityService::browseBookRes>(Arena*);
template<> ::bookCityService::delBookReq* Arena::CreateMaybeMessage<::bookCityService::delBookReq>(Arena*);
template<> ::bookCityService::fuzzySearchRequest* Arena::CreateMaybeMessage<::bookCityService::fuzzySearchRequest>(Arena*);
template<> ::bookCityService::getAllBookInfoReq* Arena::CreateMaybeMessage<::bookCityService::getAllBookInfoReq>(Arena*);
template<> ::bookCityService::getBookTypeReq* Arena::CreateMaybeMessage<::bookCityService::getBookTypeReq>(Arena*);
template<> ::bookCityService::mostlySearchRes* Arena::CreateMaybeMessage<::bookCityService::mostlySearchRes>(Arena*);
template<> ::bookCityService::mostlybooks* Arena::CreateMaybeMessage<::bookCityService::mostlybooks>(Arena*);
template<> ::bookCityService::recommendBookReq* Arena::CreateMaybeMessage<::bookCityService::recommendBookReq>(Arena*);
template<> ::bookCityService::recommendBookRes* Arena::CreateMaybeMessage<::bookCityService::recommendBookRes>(Arena*);
template<> ::bookCityService::searchBookReq* Arena::CreateMaybeMessage<::bookCityService::searchBookReq>(Arena*);
template<> ::bookCityService::universalBlankReq* Arena::CreateMaybeMessage<::bookCityService::universalBlankReq>(Arena*);
template<> ::bookCityService::updateBookBaseInfo* Arena::CreateMaybeMessage<::bookCityService::updateBookBaseInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace bookCityService {

// ===================================================================

class bookBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.bookBaseInfo) */ {
 public:
  bookBaseInfo();
  virtual ~bookBaseInfo();

  bookBaseInfo(const bookBaseInfo& from);

  inline bookBaseInfo& operator=(const bookBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bookBaseInfo(bookBaseInfo&& from) noexcept
    : bookBaseInfo() {
    *this = ::std::move(from);
  }

  inline bookBaseInfo& operator=(bookBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bookBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bookBaseInfo* internal_default_instance() {
    return reinterpret_cast<const bookBaseInfo*>(
               &_bookBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(bookBaseInfo* other);
  friend void swap(bookBaseInfo& a, bookBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bookBaseInfo* New() const final {
    return CreateMaybeMessage<bookBaseInfo>(NULL);
  }

  bookBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bookBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bookBaseInfo& from);
  void MergeFrom(const bookBaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bookBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bookName = 1;
  bool has_bookname() const;
  void clear_bookname();
  static const int kBookNameFieldNumber = 1;
  const ::std::string& bookname() const;
  void set_bookname(const ::std::string& value);
  #if LANG_CXX11
  void set_bookname(::std::string&& value);
  #endif
  void set_bookname(const char* value);
  void set_bookname(const char* value, size_t size);
  ::std::string* mutable_bookname();
  ::std::string* release_bookname();
  void set_allocated_bookname(::std::string* bookname);

  // required string authorName = 2;
  bool has_authorname() const;
  void clear_authorname();
  static const int kAuthorNameFieldNumber = 2;
  const ::std::string& authorname() const;
  void set_authorname(const ::std::string& value);
  #if LANG_CXX11
  void set_authorname(::std::string&& value);
  #endif
  void set_authorname(const char* value);
  void set_authorname(const char* value, size_t size);
  ::std::string* mutable_authorname();
  ::std::string* release_authorname();
  void set_allocated_authorname(::std::string* authorname);

  // required string publishTime = 4;
  bool has_publishtime() const;
  void clear_publishtime();
  static const int kPublishTimeFieldNumber = 4;
  const ::std::string& publishtime() const;
  void set_publishtime(const ::std::string& value);
  #if LANG_CXX11
  void set_publishtime(::std::string&& value);
  #endif
  void set_publishtime(const char* value);
  void set_publishtime(const char* value, size_t size);
  ::std::string* mutable_publishtime();
  ::std::string* release_publishtime();
  void set_allocated_publishtime(::std::string* publishtime);

  // required string publishHouse = 5;
  bool has_publishhouse() const;
  void clear_publishhouse();
  static const int kPublishHouseFieldNumber = 5;
  const ::std::string& publishhouse() const;
  void set_publishhouse(const ::std::string& value);
  #if LANG_CXX11
  void set_publishhouse(::std::string&& value);
  #endif
  void set_publishhouse(const char* value);
  void set_publishhouse(const char* value, size_t size);
  ::std::string* mutable_publishhouse();
  ::std::string* release_publishhouse();
  void set_allocated_publishhouse(::std::string* publishhouse);

  // required string bookIntro = 6;
  bool has_bookintro() const;
  void clear_bookintro();
  static const int kBookIntroFieldNumber = 6;
  const ::std::string& bookintro() const;
  void set_bookintro(const ::std::string& value);
  #if LANG_CXX11
  void set_bookintro(::std::string&& value);
  #endif
  void set_bookintro(const char* value);
  void set_bookintro(const char* value, size_t size);
  ::std::string* mutable_bookintro();
  ::std::string* release_bookintro();
  void set_allocated_bookintro(::std::string* bookintro);

  // optional string bookId = 9;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 9;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // required int32 bookType = 3;
  bool has_booktype() const;
  void clear_booktype();
  static const int kBookTypeFieldNumber = 3;
  ::google::protobuf::int32 booktype() const;
  void set_booktype(::google::protobuf::int32 value);

  // required int32 bookPage = 7;
  bool has_bookpage() const;
  void clear_bookpage();
  static const int kBookPageFieldNumber = 7;
  ::google::protobuf::int32 bookpage() const;
  void set_bookpage(::google::protobuf::int32 value);

  // required int32 languageType = 8;
  bool has_languagetype() const;
  void clear_languagetype();
  static const int kLanguageTypeFieldNumber = 8;
  ::google::protobuf::int32 languagetype() const;
  void set_languagetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.bookBaseInfo)
 private:
  void set_has_bookname();
  void clear_has_bookname();
  void set_has_authorname();
  void clear_has_authorname();
  void set_has_booktype();
  void clear_has_booktype();
  void set_has_publishtime();
  void clear_has_publishtime();
  void set_has_publishhouse();
  void clear_has_publishhouse();
  void set_has_bookintro();
  void clear_has_bookintro();
  void set_has_bookpage();
  void clear_has_bookpage();
  void set_has_languagetype();
  void clear_has_languagetype();
  void set_has_bookid();
  void clear_has_bookid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookname_;
  ::google::protobuf::internal::ArenaStringPtr authorname_;
  ::google::protobuf::internal::ArenaStringPtr publishtime_;
  ::google::protobuf::internal::ArenaStringPtr publishhouse_;
  ::google::protobuf::internal::ArenaStringPtr bookintro_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::google::protobuf::int32 booktype_;
  ::google::protobuf::int32 bookpage_;
  ::google::protobuf::int32 languagetype_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class updateBookBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.updateBookBaseInfo) */ {
 public:
  updateBookBaseInfo();
  virtual ~updateBookBaseInfo();

  updateBookBaseInfo(const updateBookBaseInfo& from);

  inline updateBookBaseInfo& operator=(const updateBookBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  updateBookBaseInfo(updateBookBaseInfo&& from) noexcept
    : updateBookBaseInfo() {
    *this = ::std::move(from);
  }

  inline updateBookBaseInfo& operator=(updateBookBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const updateBookBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const updateBookBaseInfo* internal_default_instance() {
    return reinterpret_cast<const updateBookBaseInfo*>(
               &_updateBookBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(updateBookBaseInfo* other);
  friend void swap(updateBookBaseInfo& a, updateBookBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline updateBookBaseInfo* New() const final {
    return CreateMaybeMessage<updateBookBaseInfo>(NULL);
  }

  updateBookBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<updateBookBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const updateBookBaseInfo& from);
  void MergeFrom(const updateBookBaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(updateBookBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bookName = 1;
  bool has_bookname() const;
  void clear_bookname();
  static const int kBookNameFieldNumber = 1;
  const ::std::string& bookname() const;
  void set_bookname(const ::std::string& value);
  #if LANG_CXX11
  void set_bookname(::std::string&& value);
  #endif
  void set_bookname(const char* value);
  void set_bookname(const char* value, size_t size);
  ::std::string* mutable_bookname();
  ::std::string* release_bookname();
  void set_allocated_bookname(::std::string* bookname);

  // optional string authorName = 2;
  bool has_authorname() const;
  void clear_authorname();
  static const int kAuthorNameFieldNumber = 2;
  const ::std::string& authorname() const;
  void set_authorname(const ::std::string& value);
  #if LANG_CXX11
  void set_authorname(::std::string&& value);
  #endif
  void set_authorname(const char* value);
  void set_authorname(const char* value, size_t size);
  ::std::string* mutable_authorname();
  ::std::string* release_authorname();
  void set_allocated_authorname(::std::string* authorname);

  // optional string publishTime = 4;
  bool has_publishtime() const;
  void clear_publishtime();
  static const int kPublishTimeFieldNumber = 4;
  const ::std::string& publishtime() const;
  void set_publishtime(const ::std::string& value);
  #if LANG_CXX11
  void set_publishtime(::std::string&& value);
  #endif
  void set_publishtime(const char* value);
  void set_publishtime(const char* value, size_t size);
  ::std::string* mutable_publishtime();
  ::std::string* release_publishtime();
  void set_allocated_publishtime(::std::string* publishtime);

  // optional string publishHouse = 5;
  bool has_publishhouse() const;
  void clear_publishhouse();
  static const int kPublishHouseFieldNumber = 5;
  const ::std::string& publishhouse() const;
  void set_publishhouse(const ::std::string& value);
  #if LANG_CXX11
  void set_publishhouse(::std::string&& value);
  #endif
  void set_publishhouse(const char* value);
  void set_publishhouse(const char* value, size_t size);
  ::std::string* mutable_publishhouse();
  ::std::string* release_publishhouse();
  void set_allocated_publishhouse(::std::string* publishhouse);

  // optional string bookIntro = 6;
  bool has_bookintro() const;
  void clear_bookintro();
  static const int kBookIntroFieldNumber = 6;
  const ::std::string& bookintro() const;
  void set_bookintro(const ::std::string& value);
  #if LANG_CXX11
  void set_bookintro(::std::string&& value);
  #endif
  void set_bookintro(const char* value);
  void set_bookintro(const char* value, size_t size);
  ::std::string* mutable_bookintro();
  ::std::string* release_bookintro();
  void set_allocated_bookintro(::std::string* bookintro);

  // required string bookId = 9;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 9;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // optional int32 bookType = 3;
  bool has_booktype() const;
  void clear_booktype();
  static const int kBookTypeFieldNumber = 3;
  ::google::protobuf::int32 booktype() const;
  void set_booktype(::google::protobuf::int32 value);

  // optional int32 bookPage = 7;
  bool has_bookpage() const;
  void clear_bookpage();
  static const int kBookPageFieldNumber = 7;
  ::google::protobuf::int32 bookpage() const;
  void set_bookpage(::google::protobuf::int32 value);

  // optional int32 languageType = 8;
  bool has_languagetype() const;
  void clear_languagetype();
  static const int kLanguageTypeFieldNumber = 8;
  ::google::protobuf::int32 languagetype() const;
  void set_languagetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.updateBookBaseInfo)
 private:
  void set_has_bookname();
  void clear_has_bookname();
  void set_has_authorname();
  void clear_has_authorname();
  void set_has_booktype();
  void clear_has_booktype();
  void set_has_publishtime();
  void clear_has_publishtime();
  void set_has_publishhouse();
  void clear_has_publishhouse();
  void set_has_bookintro();
  void clear_has_bookintro();
  void set_has_bookpage();
  void clear_has_bookpage();
  void set_has_languagetype();
  void clear_has_languagetype();
  void set_has_bookid();
  void clear_has_bookid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookname_;
  ::google::protobuf::internal::ArenaStringPtr authorname_;
  ::google::protobuf::internal::ArenaStringPtr publishtime_;
  ::google::protobuf::internal::ArenaStringPtr publishhouse_;
  ::google::protobuf::internal::ArenaStringPtr bookintro_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::google::protobuf::int32 booktype_;
  ::google::protobuf::int32 bookpage_;
  ::google::protobuf::int32 languagetype_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bookDownInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.bookDownInfo) */ {
 public:
  bookDownInfo();
  virtual ~bookDownInfo();

  bookDownInfo(const bookDownInfo& from);

  inline bookDownInfo& operator=(const bookDownInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bookDownInfo(bookDownInfo&& from) noexcept
    : bookDownInfo() {
    *this = ::std::move(from);
  }

  inline bookDownInfo& operator=(bookDownInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bookDownInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bookDownInfo* internal_default_instance() {
    return reinterpret_cast<const bookDownInfo*>(
               &_bookDownInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(bookDownInfo* other);
  friend void swap(bookDownInfo& a, bookDownInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bookDownInfo* New() const final {
    return CreateMaybeMessage<bookDownInfo>(NULL);
  }

  bookDownInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bookDownInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bookDownInfo& from);
  void MergeFrom(const bookDownInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bookDownInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bookHeadUrl = 2;
  bool has_bookheadurl() const;
  void clear_bookheadurl();
  static const int kBookHeadUrlFieldNumber = 2;
  const ::std::string& bookheadurl() const;
  void set_bookheadurl(const ::std::string& value);
  #if LANG_CXX11
  void set_bookheadurl(::std::string&& value);
  #endif
  void set_bookheadurl(const char* value);
  void set_bookheadurl(const char* value, size_t size);
  ::std::string* mutable_bookheadurl();
  ::std::string* release_bookheadurl();
  void set_allocated_bookheadurl(::std::string* bookheadurl);

  // required string bookDownUrl = 3;
  bool has_bookdownurl() const;
  void clear_bookdownurl();
  static const int kBookDownUrlFieldNumber = 3;
  const ::std::string& bookdownurl() const;
  void set_bookdownurl(const ::std::string& value);
  #if LANG_CXX11
  void set_bookdownurl(::std::string&& value);
  #endif
  void set_bookdownurl(const char* value);
  void set_bookdownurl(const char* value, size_t size);
  ::std::string* mutable_bookdownurl();
  ::std::string* release_bookdownurl();
  void set_allocated_bookdownurl(::std::string* bookdownurl);

  // required int32 fileSize = 1;
  bool has_filesize() const;
  void clear_filesize();
  static const int kFileSizeFieldNumber = 1;
  ::google::protobuf::int32 filesize() const;
  void set_filesize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.bookDownInfo)
 private:
  void set_has_filesize();
  void clear_has_filesize();
  void set_has_bookheadurl();
  void clear_has_bookheadurl();
  void set_has_bookdownurl();
  void clear_has_bookdownurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookheadurl_;
  ::google::protobuf::internal::ArenaStringPtr bookdownurl_;
  ::google::protobuf::int32 filesize_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bookGradeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.bookGradeInfo) */ {
 public:
  bookGradeInfo();
  virtual ~bookGradeInfo();

  bookGradeInfo(const bookGradeInfo& from);

  inline bookGradeInfo& operator=(const bookGradeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bookGradeInfo(bookGradeInfo&& from) noexcept
    : bookGradeInfo() {
    *this = ::std::move(from);
  }

  inline bookGradeInfo& operator=(bookGradeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bookGradeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bookGradeInfo* internal_default_instance() {
    return reinterpret_cast<const bookGradeInfo*>(
               &_bookGradeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(bookGradeInfo* other);
  friend void swap(bookGradeInfo& a, bookGradeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bookGradeInfo* New() const final {
    return CreateMaybeMessage<bookGradeInfo>(NULL);
  }

  bookGradeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bookGradeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bookGradeInfo& from);
  void MergeFrom(const bookGradeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bookGradeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 remarkCount = 1;
  bool has_remarkcount() const;
  void clear_remarkcount();
  static const int kRemarkCountFieldNumber = 1;
  ::google::protobuf::int32 remarkcount() const;
  void set_remarkcount(::google::protobuf::int32 value);

  // required float averageScore = 2;
  bool has_averagescore() const;
  void clear_averagescore();
  static const int kAverageScoreFieldNumber = 2;
  float averagescore() const;
  void set_averagescore(float value);

  // @@protoc_insertion_point(class_scope:bookCityService.bookGradeInfo)
 private:
  void set_has_remarkcount();
  void clear_has_remarkcount();
  void set_has_averagescore();
  void clear_has_averagescore();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 remarkcount_;
  float averagescore_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class boocomCombinekInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.boocomCombinekInfo) */ {
 public:
  boocomCombinekInfo();
  virtual ~boocomCombinekInfo();

  boocomCombinekInfo(const boocomCombinekInfo& from);

  inline boocomCombinekInfo& operator=(const boocomCombinekInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  boocomCombinekInfo(boocomCombinekInfo&& from) noexcept
    : boocomCombinekInfo() {
    *this = ::std::move(from);
  }

  inline boocomCombinekInfo& operator=(boocomCombinekInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boocomCombinekInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const boocomCombinekInfo* internal_default_instance() {
    return reinterpret_cast<const boocomCombinekInfo*>(
               &_boocomCombinekInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(boocomCombinekInfo* other);
  friend void swap(boocomCombinekInfo& a, boocomCombinekInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline boocomCombinekInfo* New() const final {
    return CreateMaybeMessage<boocomCombinekInfo>(NULL);
  }

  boocomCombinekInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<boocomCombinekInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const boocomCombinekInfo& from);
  void MergeFrom(const boocomCombinekInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(boocomCombinekInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bookId = 1;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 1;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // required .bookCityService.bookBaseInfo baseInfo = 2;
  bool has_baseinfo() const;
  void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 2;
  private:
  const ::bookCityService::bookBaseInfo& _internal_baseinfo() const;
  public:
  const ::bookCityService::bookBaseInfo& baseinfo() const;
  ::bookCityService::bookBaseInfo* release_baseinfo();
  ::bookCityService::bookBaseInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::bookCityService::bookBaseInfo* baseinfo);

  // required .bookCityService.bookDownInfo downInfo = 3;
  bool has_downinfo() const;
  void clear_downinfo();
  static const int kDownInfoFieldNumber = 3;
  private:
  const ::bookCityService::bookDownInfo& _internal_downinfo() const;
  public:
  const ::bookCityService::bookDownInfo& downinfo() const;
  ::bookCityService::bookDownInfo* release_downinfo();
  ::bookCityService::bookDownInfo* mutable_downinfo();
  void set_allocated_downinfo(::bookCityService::bookDownInfo* downinfo);

  // required .bookCityService.bookGradeInfo gradeInfo = 4;
  bool has_gradeinfo() const;
  void clear_gradeinfo();
  static const int kGradeInfoFieldNumber = 4;
  private:
  const ::bookCityService::bookGradeInfo& _internal_gradeinfo() const;
  public:
  const ::bookCityService::bookGradeInfo& gradeinfo() const;
  ::bookCityService::bookGradeInfo* release_gradeinfo();
  ::bookCityService::bookGradeInfo* mutable_gradeinfo();
  void set_allocated_gradeinfo(::bookCityService::bookGradeInfo* gradeinfo);

  // @@protoc_insertion_point(class_scope:bookCityService.boocomCombinekInfo)
 private:
  void set_has_bookid();
  void clear_has_bookid();
  void set_has_baseinfo();
  void clear_has_baseinfo();
  void set_has_downinfo();
  void clear_has_downinfo();
  void set_has_gradeinfo();
  void clear_has_gradeinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::bookCityService::bookBaseInfo* baseinfo_;
  ::bookCityService::bookDownInfo* downinfo_;
  ::bookCityService::bookGradeInfo* gradeinfo_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bookMarkItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.bookMarkItem) */ {
 public:
  bookMarkItem();
  virtual ~bookMarkItem();

  bookMarkItem(const bookMarkItem& from);

  inline bookMarkItem& operator=(const bookMarkItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bookMarkItem(bookMarkItem&& from) noexcept
    : bookMarkItem() {
    *this = ::std::move(from);
  }

  inline bookMarkItem& operator=(bookMarkItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bookMarkItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bookMarkItem* internal_default_instance() {
    return reinterpret_cast<const bookMarkItem*>(
               &_bookMarkItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(bookMarkItem* other);
  friend void swap(bookMarkItem& a, bookMarkItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bookMarkItem* New() const final {
    return CreateMaybeMessage<bookMarkItem>(NULL);
  }

  bookMarkItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bookMarkItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bookMarkItem& from);
  void MergeFrom(const bookMarkItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bookMarkItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bookId = 1;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 1;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // @@protoc_insertion_point(class_scope:bookCityService.bookMarkItem)
 private:
  void set_has_bookid();
  void clear_has_bookid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getAllBookInfoReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.getAllBookInfoReq) */ {
 public:
  getAllBookInfoReq();
  virtual ~getAllBookInfoReq();

  getAllBookInfoReq(const getAllBookInfoReq& from);

  inline getAllBookInfoReq& operator=(const getAllBookInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  getAllBookInfoReq(getAllBookInfoReq&& from) noexcept
    : getAllBookInfoReq() {
    *this = ::std::move(from);
  }

  inline getAllBookInfoReq& operator=(getAllBookInfoReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getAllBookInfoReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getAllBookInfoReq* internal_default_instance() {
    return reinterpret_cast<const getAllBookInfoReq*>(
               &_getAllBookInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(getAllBookInfoReq* other);
  friend void swap(getAllBookInfoReq& a, getAllBookInfoReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline getAllBookInfoReq* New() const final {
    return CreateMaybeMessage<getAllBookInfoReq>(NULL);
  }

  getAllBookInfoReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<getAllBookInfoReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const getAllBookInfoReq& from);
  void MergeFrom(const getAllBookInfoReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllBookInfoReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // optional int32 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.getAllBookInfoReq)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 size_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class searchBookReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.searchBookReq) */ {
 public:
  searchBookReq();
  virtual ~searchBookReq();

  searchBookReq(const searchBookReq& from);

  inline searchBookReq& operator=(const searchBookReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  searchBookReq(searchBookReq&& from) noexcept
    : searchBookReq() {
    *this = ::std::move(from);
  }

  inline searchBookReq& operator=(searchBookReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const searchBookReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const searchBookReq* internal_default_instance() {
    return reinterpret_cast<const searchBookReq*>(
               &_searchBookReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(searchBookReq* other);
  friend void swap(searchBookReq& a, searchBookReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline searchBookReq* New() const final {
    return CreateMaybeMessage<searchBookReq>(NULL);
  }

  searchBookReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<searchBookReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const searchBookReq& from);
  void MergeFrom(const searchBookReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(searchBookReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bookId = 2;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 2;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // optional string bookName = 3;
  bool has_bookname() const;
  void clear_bookname();
  static const int kBookNameFieldNumber = 3;
  const ::std::string& bookname() const;
  void set_bookname(const ::std::string& value);
  #if LANG_CXX11
  void set_bookname(::std::string&& value);
  #endif
  void set_bookname(const char* value);
  void set_bookname(const char* value, size_t size);
  ::std::string* mutable_bookname();
  ::std::string* release_bookname();
  void set_allocated_bookname(::std::string* bookname);

  // optional string authorName = 4;
  bool has_authorname() const;
  void clear_authorname();
  static const int kAuthorNameFieldNumber = 4;
  const ::std::string& authorname() const;
  void set_authorname(const ::std::string& value);
  #if LANG_CXX11
  void set_authorname(::std::string&& value);
  #endif
  void set_authorname(const char* value);
  void set_authorname(const char* value, size_t size);
  ::std::string* mutable_authorname();
  ::std::string* release_authorname();
  void set_allocated_authorname(::std::string* authorname);

  // optional string publishHouse = 6;
  bool has_publishhouse() const;
  void clear_publishhouse();
  static const int kPublishHouseFieldNumber = 6;
  const ::std::string& publishhouse() const;
  void set_publishhouse(const ::std::string& value);
  #if LANG_CXX11
  void set_publishhouse(::std::string&& value);
  #endif
  void set_publishhouse(const char* value);
  void set_publishhouse(const char* value, size_t size);
  ::std::string* mutable_publishhouse();
  ::std::string* release_publishhouse();
  void set_allocated_publishhouse(::std::string* publishhouse);

  // required string dayTime = 7;
  bool has_daytime() const;
  void clear_daytime();
  static const int kDayTimeFieldNumber = 7;
  const ::std::string& daytime() const;
  void set_daytime(const ::std::string& value);
  #if LANG_CXX11
  void set_daytime(::std::string&& value);
  #endif
  void set_daytime(const char* value);
  void set_daytime(const char* value, size_t size);
  ::std::string* mutable_daytime();
  ::std::string* release_daytime();
  void set_allocated_daytime(::std::string* daytime);

  // optional int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // optional int32 bookType = 5;
  bool has_booktype() const;
  void clear_booktype();
  static const int kBookTypeFieldNumber = 5;
  ::google::protobuf::int32 booktype() const;
  void set_booktype(::google::protobuf::int32 value);

  // required int32 offset = 8;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 8;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // required int32 count = 9;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 9;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.searchBookReq)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_bookid();
  void clear_has_bookid();
  void set_has_bookname();
  void clear_has_bookname();
  void set_has_authorname();
  void clear_has_authorname();
  void set_has_booktype();
  void clear_has_booktype();
  void set_has_publishhouse();
  void clear_has_publishhouse();
  void set_has_daytime();
  void clear_has_daytime();
  void set_has_offset();
  void clear_has_offset();
  void set_has_count();
  void clear_has_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::google::protobuf::internal::ArenaStringPtr bookname_;
  ::google::protobuf::internal::ArenaStringPtr authorname_;
  ::google::protobuf::internal::ArenaStringPtr publishhouse_;
  ::google::protobuf::internal::ArenaStringPtr daytime_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 booktype_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class booksRespList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.booksRespList) */ {
 public:
  booksRespList();
  virtual ~booksRespList();

  booksRespList(const booksRespList& from);

  inline booksRespList& operator=(const booksRespList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  booksRespList(booksRespList&& from) noexcept
    : booksRespList() {
    *this = ::std::move(from);
  }

  inline booksRespList& operator=(booksRespList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const booksRespList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const booksRespList* internal_default_instance() {
    return reinterpret_cast<const booksRespList*>(
               &_booksRespList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(booksRespList* other);
  friend void swap(booksRespList& a, booksRespList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline booksRespList* New() const final {
    return CreateMaybeMessage<booksRespList>(NULL);
  }

  booksRespList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<booksRespList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const booksRespList& from);
  void MergeFrom(const booksRespList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(booksRespList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bookCityService.boocomCombinekInfo lists = 2;
  int lists_size() const;
  void clear_lists();
  static const int kListsFieldNumber = 2;
  ::bookCityService::boocomCombinekInfo* mutable_lists(int index);
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
      mutable_lists();
  const ::bookCityService::boocomCombinekInfo& lists(int index) const;
  ::bookCityService::boocomCombinekInfo* add_lists();
  const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
      lists() const;

  // optional string userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // required int32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.booksRespList)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo > lists_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getBookTypeReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.getBookTypeReq) */ {
 public:
  getBookTypeReq();
  virtual ~getBookTypeReq();

  getBookTypeReq(const getBookTypeReq& from);

  inline getBookTypeReq& operator=(const getBookTypeReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  getBookTypeReq(getBookTypeReq&& from) noexcept
    : getBookTypeReq() {
    *this = ::std::move(from);
  }

  inline getBookTypeReq& operator=(getBookTypeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getBookTypeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getBookTypeReq* internal_default_instance() {
    return reinterpret_cast<const getBookTypeReq*>(
               &_getBookTypeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(getBookTypeReq* other);
  friend void swap(getBookTypeReq& a, getBookTypeReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline getBookTypeReq* New() const final {
    return CreateMaybeMessage<getBookTypeReq>(NULL);
  }

  getBookTypeReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<getBookTypeReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const getBookTypeReq& from);
  void MergeFrom(const getBookTypeReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getBookTypeReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional int32 offset = 3;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // required int32 count = 4;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 4;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // optional int32 sortMethod = 5;
  bool has_sortmethod() const;
  void clear_sortmethod();
  static const int kSortMethodFieldNumber = 5;
  ::google::protobuf::int32 sortmethod() const;
  void set_sortmethod(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.getBookTypeReq)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_type();
  void clear_has_type();
  void set_has_offset();
  void clear_has_offset();
  void set_has_count();
  void clear_has_count();
  void set_has_sortmethod();
  void clear_has_sortmethod();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 sortmethod_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class delBookReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.delBookReq) */ {
 public:
  delBookReq();
  virtual ~delBookReq();

  delBookReq(const delBookReq& from);

  inline delBookReq& operator=(const delBookReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  delBookReq(delBookReq&& from) noexcept
    : delBookReq() {
    *this = ::std::move(from);
  }

  inline delBookReq& operator=(delBookReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const delBookReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const delBookReq* internal_default_instance() {
    return reinterpret_cast<const delBookReq*>(
               &_delBookReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(delBookReq* other);
  friend void swap(delBookReq& a, delBookReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline delBookReq* New() const final {
    return CreateMaybeMessage<delBookReq>(NULL);
  }

  delBookReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<delBookReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const delBookReq& from);
  void MergeFrom(const delBookReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(delBookReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // required string bookId = 2;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 2;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // optional string delTime = 3;
  bool has_deltime() const;
  void clear_deltime();
  static const int kDelTimeFieldNumber = 3;
  const ::std::string& deltime() const;
  void set_deltime(const ::std::string& value);
  #if LANG_CXX11
  void set_deltime(::std::string&& value);
  #endif
  void set_deltime(const char* value);
  void set_deltime(const char* value, size_t size);
  ::std::string* mutable_deltime();
  ::std::string* release_deltime();
  void set_allocated_deltime(::std::string* deltime);

  // @@protoc_insertion_point(class_scope:bookCityService.delBookReq)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_bookid();
  void clear_has_bookid();
  void set_has_deltime();
  void clear_has_deltime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::google::protobuf::internal::ArenaStringPtr deltime_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class adsReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.adsReq) */ {
 public:
  adsReq();
  virtual ~adsReq();

  adsReq(const adsReq& from);

  inline adsReq& operator=(const adsReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  adsReq(adsReq&& from) noexcept
    : adsReq() {
    *this = ::std::move(from);
  }

  inline adsReq& operator=(adsReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const adsReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const adsReq* internal_default_instance() {
    return reinterpret_cast<const adsReq*>(
               &_adsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(adsReq* other);
  friend void swap(adsReq& a, adsReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline adsReq* New() const final {
    return CreateMaybeMessage<adsReq>(NULL);
  }

  adsReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<adsReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const adsReq& from);
  void MergeFrom(const adsReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(adsReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bookId = 1;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 1;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // optional string adUrl = 2;
  bool has_adurl() const;
  void clear_adurl();
  static const int kAdUrlFieldNumber = 2;
  const ::std::string& adurl() const;
  void set_adurl(const ::std::string& value);
  #if LANG_CXX11
  void set_adurl(::std::string&& value);
  #endif
  void set_adurl(const char* value);
  void set_adurl(const char* value, size_t size);
  ::std::string* mutable_adurl();
  ::std::string* release_adurl();
  void set_allocated_adurl(::std::string* adurl);

  // @@protoc_insertion_point(class_scope:bookCityService.adsReq)
 private:
  void set_has_bookid();
  void clear_has_bookid();
  void set_has_adurl();
  void clear_has_adurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::google::protobuf::internal::ArenaStringPtr adurl_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class adInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.adInfo) */ {
 public:
  adInfo();
  virtual ~adInfo();

  adInfo(const adInfo& from);

  inline adInfo& operator=(const adInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  adInfo(adInfo&& from) noexcept
    : adInfo() {
    *this = ::std::move(from);
  }

  inline adInfo& operator=(adInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const adInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const adInfo* internal_default_instance() {
    return reinterpret_cast<const adInfo*>(
               &_adInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(adInfo* other);
  friend void swap(adInfo& a, adInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline adInfo* New() const final {
    return CreateMaybeMessage<adInfo>(NULL);
  }

  adInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<adInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const adInfo& from);
  void MergeFrom(const adInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(adInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bookCityService.boocomCombinekInfo lists = 2;
  int lists_size() const;
  void clear_lists();
  static const int kListsFieldNumber = 2;
  ::bookCityService::boocomCombinekInfo* mutable_lists(int index);
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
      mutable_lists();
  const ::bookCityService::boocomCombinekInfo& lists(int index) const;
  ::bookCityService::boocomCombinekInfo* add_lists();
  const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
      lists() const;

  // optional string adUrl = 1;
  bool has_adurl() const;
  void clear_adurl();
  static const int kAdUrlFieldNumber = 1;
  const ::std::string& adurl() const;
  void set_adurl(const ::std::string& value);
  #if LANG_CXX11
  void set_adurl(::std::string&& value);
  #endif
  void set_adurl(const char* value);
  void set_adurl(const char* value, size_t size);
  ::std::string* mutable_adurl();
  ::std::string* release_adurl();
  void set_allocated_adurl(::std::string* adurl);

  // @@protoc_insertion_point(class_scope:bookCityService.adInfo)
 private:
  void set_has_adurl();
  void clear_has_adurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo > lists_;
  ::google::protobuf::internal::ArenaStringPtr adurl_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class adsRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.adsRes) */ {
 public:
  adsRes();
  virtual ~adsRes();

  adsRes(const adsRes& from);

  inline adsRes& operator=(const adsRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  adsRes(adsRes&& from) noexcept
    : adsRes() {
    *this = ::std::move(from);
  }

  inline adsRes& operator=(adsRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const adsRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const adsRes* internal_default_instance() {
    return reinterpret_cast<const adsRes*>(
               &_adsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(adsRes* other);
  friend void swap(adsRes& a, adsRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline adsRes* New() const final {
    return CreateMaybeMessage<adsRes>(NULL);
  }

  adsRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<adsRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const adsRes& from);
  void MergeFrom(const adsRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(adsRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bookCityService.adInfo lists = 1;
  int lists_size() const;
  void clear_lists();
  static const int kListsFieldNumber = 1;
  ::bookCityService::adInfo* mutable_lists(int index);
  ::google::protobuf::RepeatedPtrField< ::bookCityService::adInfo >*
      mutable_lists();
  const ::bookCityService::adInfo& lists(int index) const;
  ::bookCityService::adInfo* add_lists();
  const ::google::protobuf::RepeatedPtrField< ::bookCityService::adInfo >&
      lists() const;

  // required int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.adsRes)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bookCityService::adInfo > lists_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class recommendBookReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.recommendBookReq) */ {
 public:
  recommendBookReq();
  virtual ~recommendBookReq();

  recommendBookReq(const recommendBookReq& from);

  inline recommendBookReq& operator=(const recommendBookReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  recommendBookReq(recommendBookReq&& from) noexcept
    : recommendBookReq() {
    *this = ::std::move(from);
  }

  inline recommendBookReq& operator=(recommendBookReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recommendBookReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const recommendBookReq* internal_default_instance() {
    return reinterpret_cast<const recommendBookReq*>(
               &_recommendBookReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(recommendBookReq* other);
  friend void swap(recommendBookReq& a, recommendBookReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline recommendBookReq* New() const final {
    return CreateMaybeMessage<recommendBookReq>(NULL);
  }

  recommendBookReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<recommendBookReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const recommendBookReq& from);
  void MergeFrom(const recommendBookReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(recommendBookReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.recommendBookReq)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class recommendBookRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.recommendBookRes) */ {
 public:
  recommendBookRes();
  virtual ~recommendBookRes();

  recommendBookRes(const recommendBookRes& from);

  inline recommendBookRes& operator=(const recommendBookRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  recommendBookRes(recommendBookRes&& from) noexcept
    : recommendBookRes() {
    *this = ::std::move(from);
  }

  inline recommendBookRes& operator=(recommendBookRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recommendBookRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const recommendBookRes* internal_default_instance() {
    return reinterpret_cast<const recommendBookRes*>(
               &_recommendBookRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(recommendBookRes* other);
  friend void swap(recommendBookRes& a, recommendBookRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline recommendBookRes* New() const final {
    return CreateMaybeMessage<recommendBookRes>(NULL);
  }

  recommendBookRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<recommendBookRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const recommendBookRes& from);
  void MergeFrom(const recommendBookRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(recommendBookRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bookCityService.boocomCombinekInfo lists = 1;
  int lists_size() const;
  void clear_lists();
  static const int kListsFieldNumber = 1;
  ::bookCityService::boocomCombinekInfo* mutable_lists(int index);
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
      mutable_lists();
  const ::bookCityService::boocomCombinekInfo& lists(int index) const;
  ::bookCityService::boocomCombinekInfo* add_lists();
  const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
      lists() const;

  // required int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.recommendBookRes)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo > lists_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class browseBookReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.browseBookReq) */ {
 public:
  browseBookReq();
  virtual ~browseBookReq();

  browseBookReq(const browseBookReq& from);

  inline browseBookReq& operator=(const browseBookReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  browseBookReq(browseBookReq&& from) noexcept
    : browseBookReq() {
    *this = ::std::move(from);
  }

  inline browseBookReq& operator=(browseBookReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const browseBookReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const browseBookReq* internal_default_instance() {
    return reinterpret_cast<const browseBookReq*>(
               &_browseBookReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(browseBookReq* other);
  friend void swap(browseBookReq& a, browseBookReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline browseBookReq* New() const final {
    return CreateMaybeMessage<browseBookReq>(NULL);
  }

  browseBookReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<browseBookReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const browseBookReq& from);
  void MergeFrom(const browseBookReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(browseBookReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.browseBookReq)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class browseBookRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.browseBookRes) */ {
 public:
  browseBookRes();
  virtual ~browseBookRes();

  browseBookRes(const browseBookRes& from);

  inline browseBookRes& operator=(const browseBookRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  browseBookRes(browseBookRes&& from) noexcept
    : browseBookRes() {
    *this = ::std::move(from);
  }

  inline browseBookRes& operator=(browseBookRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const browseBookRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const browseBookRes* internal_default_instance() {
    return reinterpret_cast<const browseBookRes*>(
               &_browseBookRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(browseBookRes* other);
  friend void swap(browseBookRes& a, browseBookRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline browseBookRes* New() const final {
    return CreateMaybeMessage<browseBookRes>(NULL);
  }

  browseBookRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<browseBookRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const browseBookRes& from);
  void MergeFrom(const browseBookRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(browseBookRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bookCityService.boocomCombinekInfo lists = 1;
  int lists_size() const;
  void clear_lists();
  static const int kListsFieldNumber = 1;
  ::bookCityService::boocomCombinekInfo* mutable_lists(int index);
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
      mutable_lists();
  const ::bookCityService::boocomCombinekInfo& lists(int index) const;
  ::bookCityService::boocomCombinekInfo* add_lists();
  const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
      lists() const;

  // required int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.browseBookRes)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo > lists_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class universalBlankReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.universalBlankReq) */ {
 public:
  universalBlankReq();
  virtual ~universalBlankReq();

  universalBlankReq(const universalBlankReq& from);

  inline universalBlankReq& operator=(const universalBlankReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  universalBlankReq(universalBlankReq&& from) noexcept
    : universalBlankReq() {
    *this = ::std::move(from);
  }

  inline universalBlankReq& operator=(universalBlankReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const universalBlankReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const universalBlankReq* internal_default_instance() {
    return reinterpret_cast<const universalBlankReq*>(
               &_universalBlankReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(universalBlankReq* other);
  friend void swap(universalBlankReq& a, universalBlankReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline universalBlankReq* New() const final {
    return CreateMaybeMessage<universalBlankReq>(NULL);
  }

  universalBlankReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<universalBlankReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const universalBlankReq& from);
  void MergeFrom(const universalBlankReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(universalBlankReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dayTime = 1;
  bool has_daytime() const;
  void clear_daytime();
  static const int kDayTimeFieldNumber = 1;
  const ::std::string& daytime() const;
  void set_daytime(const ::std::string& value);
  #if LANG_CXX11
  void set_daytime(::std::string&& value);
  #endif
  void set_daytime(const char* value);
  void set_daytime(const char* value, size_t size);
  ::std::string* mutable_daytime();
  ::std::string* release_daytime();
  void set_allocated_daytime(::std::string* daytime);

  // optional int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.universalBlankReq)
 private:
  void set_has_daytime();
  void clear_has_daytime();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr daytime_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class mostlybooks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.mostlybooks) */ {
 public:
  mostlybooks();
  virtual ~mostlybooks();

  mostlybooks(const mostlybooks& from);

  inline mostlybooks& operator=(const mostlybooks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  mostlybooks(mostlybooks&& from) noexcept
    : mostlybooks() {
    *this = ::std::move(from);
  }

  inline mostlybooks& operator=(mostlybooks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mostlybooks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mostlybooks* internal_default_instance() {
    return reinterpret_cast<const mostlybooks*>(
               &_mostlybooks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(mostlybooks* other);
  friend void swap(mostlybooks& a, mostlybooks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline mostlybooks* New() const final {
    return CreateMaybeMessage<mostlybooks>(NULL);
  }

  mostlybooks* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<mostlybooks>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const mostlybooks& from);
  void MergeFrom(const mostlybooks& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mostlybooks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bookId = 1;
  bool has_bookid() const;
  void clear_bookid();
  static const int kBookIdFieldNumber = 1;
  const ::std::string& bookid() const;
  void set_bookid(const ::std::string& value);
  #if LANG_CXX11
  void set_bookid(::std::string&& value);
  #endif
  void set_bookid(const char* value);
  void set_bookid(const char* value, size_t size);
  ::std::string* mutable_bookid();
  ::std::string* release_bookid();
  void set_allocated_bookid(::std::string* bookid);

  // required string bookName = 2;
  bool has_bookname() const;
  void clear_bookname();
  static const int kBookNameFieldNumber = 2;
  const ::std::string& bookname() const;
  void set_bookname(const ::std::string& value);
  #if LANG_CXX11
  void set_bookname(::std::string&& value);
  #endif
  void set_bookname(const char* value);
  void set_bookname(const char* value, size_t size);
  ::std::string* mutable_bookname();
  ::std::string* release_bookname();
  void set_allocated_bookname(::std::string* bookname);

  // required int32 searchTimes = 3;
  bool has_searchtimes() const;
  void clear_searchtimes();
  static const int kSearchTimesFieldNumber = 3;
  ::google::protobuf::int32 searchtimes() const;
  void set_searchtimes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.mostlybooks)
 private:
  void set_has_bookid();
  void clear_has_bookid();
  void set_has_bookname();
  void clear_has_bookname();
  void set_has_searchtimes();
  void clear_has_searchtimes();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bookid_;
  ::google::protobuf::internal::ArenaStringPtr bookname_;
  ::google::protobuf::int32 searchtimes_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class mostlySearchRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.mostlySearchRes) */ {
 public:
  mostlySearchRes();
  virtual ~mostlySearchRes();

  mostlySearchRes(const mostlySearchRes& from);

  inline mostlySearchRes& operator=(const mostlySearchRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  mostlySearchRes(mostlySearchRes&& from) noexcept
    : mostlySearchRes() {
    *this = ::std::move(from);
  }

  inline mostlySearchRes& operator=(mostlySearchRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mostlySearchRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mostlySearchRes* internal_default_instance() {
    return reinterpret_cast<const mostlySearchRes*>(
               &_mostlySearchRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(mostlySearchRes* other);
  friend void swap(mostlySearchRes& a, mostlySearchRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline mostlySearchRes* New() const final {
    return CreateMaybeMessage<mostlySearchRes>(NULL);
  }

  mostlySearchRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<mostlySearchRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const mostlySearchRes& from);
  void MergeFrom(const mostlySearchRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mostlySearchRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bookCityService.mostlybooks lists = 1;
  int lists_size() const;
  void clear_lists();
  static const int kListsFieldNumber = 1;
  ::bookCityService::mostlybooks* mutable_lists(int index);
  ::google::protobuf::RepeatedPtrField< ::bookCityService::mostlybooks >*
      mutable_lists();
  const ::bookCityService::mostlybooks& lists(int index) const;
  ::bookCityService::mostlybooks* add_lists();
  const ::google::protobuf::RepeatedPtrField< ::bookCityService::mostlybooks >&
      lists() const;

  // required int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.mostlySearchRes)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bookCityService::mostlybooks > lists_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fuzzySearchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bookCityService.fuzzySearchRequest) */ {
 public:
  fuzzySearchRequest();
  virtual ~fuzzySearchRequest();

  fuzzySearchRequest(const fuzzySearchRequest& from);

  inline fuzzySearchRequest& operator=(const fuzzySearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  fuzzySearchRequest(fuzzySearchRequest&& from) noexcept
    : fuzzySearchRequest() {
    *this = ::std::move(from);
  }

  inline fuzzySearchRequest& operator=(fuzzySearchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fuzzySearchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fuzzySearchRequest* internal_default_instance() {
    return reinterpret_cast<const fuzzySearchRequest*>(
               &_fuzzySearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(fuzzySearchRequest* other);
  friend void swap(fuzzySearchRequest& a, fuzzySearchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline fuzzySearchRequest* New() const final {
    return CreateMaybeMessage<fuzzySearchRequest>(NULL);
  }

  fuzzySearchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<fuzzySearchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const fuzzySearchRequest& from);
  void MergeFrom(const fuzzySearchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fuzzySearchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string words = 1;
  bool has_words() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  const ::std::string& words() const;
  void set_words(const ::std::string& value);
  #if LANG_CXX11
  void set_words(::std::string&& value);
  #endif
  void set_words(const char* value);
  void set_words(const char* value, size_t size);
  ::std::string* mutable_words();
  ::std::string* release_words();
  void set_allocated_words(::std::string* words);

  // required string dayTime = 2;
  bool has_daytime() const;
  void clear_daytime();
  static const int kDayTimeFieldNumber = 2;
  const ::std::string& daytime() const;
  void set_daytime(const ::std::string& value);
  #if LANG_CXX11
  void set_daytime(::std::string&& value);
  #endif
  void set_daytime(const char* value);
  void set_daytime(const char* value, size_t size);
  ::std::string* mutable_daytime();
  ::std::string* release_daytime();
  void set_allocated_daytime(::std::string* daytime);

  // required int32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // required int32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bookCityService.fuzzySearchRequest)
 private:
  void set_has_words();
  void clear_has_words();
  void set_has_daytime();
  void clear_has_daytime();
  void set_has_count();
  void clear_has_count();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr words_;
  ::google::protobuf::internal::ArenaStringPtr daytime_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 offset_;
  friend struct ::protobuf_bookcity_2eproto::TableStruct;
};
// ===================================================================

class bookCityService_Stub;

class bookCityService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline bookCityService() {};
 public:
  virtual ~bookCityService();

  typedef bookCityService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void addBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::bookBaseInfo* request,
                       ::commonService::commonResp* response,
                       ::google::protobuf::Closure* done);
  virtual void searchBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::searchBookReq* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
  virtual void setBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::updateBookBaseInfo* request,
                       ::commonService::commonResp* response,
                       ::google::protobuf::Closure* done);
  virtual void getAllBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::getAllBookInfoReq* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
  virtual void delBookInfoByIdFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::delBookReq* request,
                       ::commonService::commonResp* response,
                       ::google::protobuf::Closure* done);
  virtual void getBookADSFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::adsReq* request,
                       ::bookCityService::adsRes* response,
                       ::google::protobuf::Closure* done);
  virtual void getRecommendBookFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::recommendBookReq* request,
                       ::bookCityService::recommendBookRes* response,
                       ::google::protobuf::Closure* done);
  virtual void getBrowseBookFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::browseBookReq* request,
                       ::bookCityService::browseBookRes* response,
                       ::google::protobuf::Closure* done);
  virtual void getMostlySearchFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::universalBlankReq* request,
                       ::bookCityService::mostlySearchRes* response,
                       ::google::protobuf::Closure* done);
  virtual void getPopularSearchFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::universalBlankReq* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
  virtual void FuzzySearchBooksFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::fuzzySearchRequest* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(bookCityService);
};

class bookCityService_Stub : public bookCityService {
 public:
  bookCityService_Stub(::google::protobuf::RpcChannel* channel);
  bookCityService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~bookCityService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements bookCityService ------------------------------------------

  void addBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::bookBaseInfo* request,
                       ::commonService::commonResp* response,
                       ::google::protobuf::Closure* done);
  void searchBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::searchBookReq* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
  void setBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::updateBookBaseInfo* request,
                       ::commonService::commonResp* response,
                       ::google::protobuf::Closure* done);
  void getAllBookInfoFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::getAllBookInfoReq* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
  void delBookInfoByIdFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::delBookReq* request,
                       ::commonService::commonResp* response,
                       ::google::protobuf::Closure* done);
  void getBookADSFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::adsReq* request,
                       ::bookCityService::adsRes* response,
                       ::google::protobuf::Closure* done);
  void getRecommendBookFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::recommendBookReq* request,
                       ::bookCityService::recommendBookRes* response,
                       ::google::protobuf::Closure* done);
  void getBrowseBookFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::browseBookReq* request,
                       ::bookCityService::browseBookRes* response,
                       ::google::protobuf::Closure* done);
  void getMostlySearchFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::universalBlankReq* request,
                       ::bookCityService::mostlySearchRes* response,
                       ::google::protobuf::Closure* done);
  void getPopularSearchFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::universalBlankReq* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
  void FuzzySearchBooksFun(::google::protobuf::RpcController* controller,
                       const ::bookCityService::fuzzySearchRequest* request,
                       ::bookCityService::booksRespList* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(bookCityService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// bookBaseInfo

// required string bookName = 1;
inline bool bookBaseInfo::has_bookname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bookBaseInfo::set_has_bookname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bookBaseInfo::clear_has_bookname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bookBaseInfo::clear_bookname() {
  bookname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookname();
}
inline const ::std::string& bookBaseInfo::bookname() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.bookName)
  return bookname_.GetNoArena();
}
inline void bookBaseInfo::set_bookname(const ::std::string& value) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.bookName)
}
#if LANG_CXX11
inline void bookBaseInfo::set_bookname(::std::string&& value) {
  set_has_bookname();
  bookname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookBaseInfo.bookName)
}
#endif
inline void bookBaseInfo::set_bookname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookBaseInfo.bookName)
}
inline void bookBaseInfo::set_bookname(const char* value, size_t size) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookBaseInfo.bookName)
}
inline ::std::string* bookBaseInfo::mutable_bookname() {
  set_has_bookname();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookBaseInfo.bookName)
  return bookname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookBaseInfo::release_bookname() {
  // @@protoc_insertion_point(field_release:bookCityService.bookBaseInfo.bookName)
  if (!has_bookname()) {
    return NULL;
  }
  clear_has_bookname();
  return bookname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookBaseInfo::set_allocated_bookname(::std::string* bookname) {
  if (bookname != NULL) {
    set_has_bookname();
  } else {
    clear_has_bookname();
  }
  bookname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookBaseInfo.bookName)
}

// required string authorName = 2;
inline bool bookBaseInfo::has_authorname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bookBaseInfo::set_has_authorname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bookBaseInfo::clear_has_authorname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bookBaseInfo::clear_authorname() {
  authorname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authorname();
}
inline const ::std::string& bookBaseInfo::authorname() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.authorName)
  return authorname_.GetNoArena();
}
inline void bookBaseInfo::set_authorname(const ::std::string& value) {
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.authorName)
}
#if LANG_CXX11
inline void bookBaseInfo::set_authorname(::std::string&& value) {
  set_has_authorname();
  authorname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookBaseInfo.authorName)
}
#endif
inline void bookBaseInfo::set_authorname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookBaseInfo.authorName)
}
inline void bookBaseInfo::set_authorname(const char* value, size_t size) {
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookBaseInfo.authorName)
}
inline ::std::string* bookBaseInfo::mutable_authorname() {
  set_has_authorname();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookBaseInfo.authorName)
  return authorname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookBaseInfo::release_authorname() {
  // @@protoc_insertion_point(field_release:bookCityService.bookBaseInfo.authorName)
  if (!has_authorname()) {
    return NULL;
  }
  clear_has_authorname();
  return authorname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookBaseInfo::set_allocated_authorname(::std::string* authorname) {
  if (authorname != NULL) {
    set_has_authorname();
  } else {
    clear_has_authorname();
  }
  authorname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authorname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookBaseInfo.authorName)
}

// required int32 bookType = 3;
inline bool bookBaseInfo::has_booktype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void bookBaseInfo::set_has_booktype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void bookBaseInfo::clear_has_booktype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void bookBaseInfo::clear_booktype() {
  booktype_ = 0;
  clear_has_booktype();
}
inline ::google::protobuf::int32 bookBaseInfo::booktype() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.bookType)
  return booktype_;
}
inline void bookBaseInfo::set_booktype(::google::protobuf::int32 value) {
  set_has_booktype();
  booktype_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.bookType)
}

// required string publishTime = 4;
inline bool bookBaseInfo::has_publishtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bookBaseInfo::set_has_publishtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bookBaseInfo::clear_has_publishtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bookBaseInfo::clear_publishtime() {
  publishtime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_publishtime();
}
inline const ::std::string& bookBaseInfo::publishtime() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.publishTime)
  return publishtime_.GetNoArena();
}
inline void bookBaseInfo::set_publishtime(const ::std::string& value) {
  set_has_publishtime();
  publishtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.publishTime)
}
#if LANG_CXX11
inline void bookBaseInfo::set_publishtime(::std::string&& value) {
  set_has_publishtime();
  publishtime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookBaseInfo.publishTime)
}
#endif
inline void bookBaseInfo::set_publishtime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_publishtime();
  publishtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookBaseInfo.publishTime)
}
inline void bookBaseInfo::set_publishtime(const char* value, size_t size) {
  set_has_publishtime();
  publishtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookBaseInfo.publishTime)
}
inline ::std::string* bookBaseInfo::mutable_publishtime() {
  set_has_publishtime();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookBaseInfo.publishTime)
  return publishtime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookBaseInfo::release_publishtime() {
  // @@protoc_insertion_point(field_release:bookCityService.bookBaseInfo.publishTime)
  if (!has_publishtime()) {
    return NULL;
  }
  clear_has_publishtime();
  return publishtime_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookBaseInfo::set_allocated_publishtime(::std::string* publishtime) {
  if (publishtime != NULL) {
    set_has_publishtime();
  } else {
    clear_has_publishtime();
  }
  publishtime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publishtime);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookBaseInfo.publishTime)
}

// required string publishHouse = 5;
inline bool bookBaseInfo::has_publishhouse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void bookBaseInfo::set_has_publishhouse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void bookBaseInfo::clear_has_publishhouse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void bookBaseInfo::clear_publishhouse() {
  publishhouse_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_publishhouse();
}
inline const ::std::string& bookBaseInfo::publishhouse() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.publishHouse)
  return publishhouse_.GetNoArena();
}
inline void bookBaseInfo::set_publishhouse(const ::std::string& value) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.publishHouse)
}
#if LANG_CXX11
inline void bookBaseInfo::set_publishhouse(::std::string&& value) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookBaseInfo.publishHouse)
}
#endif
inline void bookBaseInfo::set_publishhouse(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookBaseInfo.publishHouse)
}
inline void bookBaseInfo::set_publishhouse(const char* value, size_t size) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookBaseInfo.publishHouse)
}
inline ::std::string* bookBaseInfo::mutable_publishhouse() {
  set_has_publishhouse();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookBaseInfo.publishHouse)
  return publishhouse_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookBaseInfo::release_publishhouse() {
  // @@protoc_insertion_point(field_release:bookCityService.bookBaseInfo.publishHouse)
  if (!has_publishhouse()) {
    return NULL;
  }
  clear_has_publishhouse();
  return publishhouse_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookBaseInfo::set_allocated_publishhouse(::std::string* publishhouse) {
  if (publishhouse != NULL) {
    set_has_publishhouse();
  } else {
    clear_has_publishhouse();
  }
  publishhouse_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publishhouse);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookBaseInfo.publishHouse)
}

// required string bookIntro = 6;
inline bool bookBaseInfo::has_bookintro() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void bookBaseInfo::set_has_bookintro() {
  _has_bits_[0] |= 0x00000010u;
}
inline void bookBaseInfo::clear_has_bookintro() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void bookBaseInfo::clear_bookintro() {
  bookintro_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookintro();
}
inline const ::std::string& bookBaseInfo::bookintro() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.bookIntro)
  return bookintro_.GetNoArena();
}
inline void bookBaseInfo::set_bookintro(const ::std::string& value) {
  set_has_bookintro();
  bookintro_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.bookIntro)
}
#if LANG_CXX11
inline void bookBaseInfo::set_bookintro(::std::string&& value) {
  set_has_bookintro();
  bookintro_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookBaseInfo.bookIntro)
}
#endif
inline void bookBaseInfo::set_bookintro(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookintro();
  bookintro_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookBaseInfo.bookIntro)
}
inline void bookBaseInfo::set_bookintro(const char* value, size_t size) {
  set_has_bookintro();
  bookintro_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookBaseInfo.bookIntro)
}
inline ::std::string* bookBaseInfo::mutable_bookintro() {
  set_has_bookintro();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookBaseInfo.bookIntro)
  return bookintro_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookBaseInfo::release_bookintro() {
  // @@protoc_insertion_point(field_release:bookCityService.bookBaseInfo.bookIntro)
  if (!has_bookintro()) {
    return NULL;
  }
  clear_has_bookintro();
  return bookintro_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookBaseInfo::set_allocated_bookintro(::std::string* bookintro) {
  if (bookintro != NULL) {
    set_has_bookintro();
  } else {
    clear_has_bookintro();
  }
  bookintro_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookintro);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookBaseInfo.bookIntro)
}

// required int32 bookPage = 7;
inline bool bookBaseInfo::has_bookpage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void bookBaseInfo::set_has_bookpage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void bookBaseInfo::clear_has_bookpage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void bookBaseInfo::clear_bookpage() {
  bookpage_ = 0;
  clear_has_bookpage();
}
inline ::google::protobuf::int32 bookBaseInfo::bookpage() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.bookPage)
  return bookpage_;
}
inline void bookBaseInfo::set_bookpage(::google::protobuf::int32 value) {
  set_has_bookpage();
  bookpage_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.bookPage)
}

// required int32 languageType = 8;
inline bool bookBaseInfo::has_languagetype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void bookBaseInfo::set_has_languagetype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void bookBaseInfo::clear_has_languagetype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void bookBaseInfo::clear_languagetype() {
  languagetype_ = 0;
  clear_has_languagetype();
}
inline ::google::protobuf::int32 bookBaseInfo::languagetype() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.languageType)
  return languagetype_;
}
inline void bookBaseInfo::set_languagetype(::google::protobuf::int32 value) {
  set_has_languagetype();
  languagetype_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.languageType)
}

// optional string bookId = 9;
inline bool bookBaseInfo::has_bookid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void bookBaseInfo::set_has_bookid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void bookBaseInfo::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void bookBaseInfo::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& bookBaseInfo::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookBaseInfo.bookId)
  return bookid_.GetNoArena();
}
inline void bookBaseInfo::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookBaseInfo.bookId)
}
#if LANG_CXX11
inline void bookBaseInfo::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookBaseInfo.bookId)
}
#endif
inline void bookBaseInfo::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookBaseInfo.bookId)
}
inline void bookBaseInfo::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookBaseInfo.bookId)
}
inline ::std::string* bookBaseInfo::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookBaseInfo.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookBaseInfo::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.bookBaseInfo.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookBaseInfo::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookBaseInfo.bookId)
}

// -------------------------------------------------------------------

// updateBookBaseInfo

// optional string bookName = 1;
inline bool updateBookBaseInfo::has_bookname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void updateBookBaseInfo::set_has_bookname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void updateBookBaseInfo::clear_has_bookname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void updateBookBaseInfo::clear_bookname() {
  bookname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookname();
}
inline const ::std::string& updateBookBaseInfo::bookname() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.bookName)
  return bookname_.GetNoArena();
}
inline void updateBookBaseInfo::set_bookname(const ::std::string& value) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.bookName)
}
#if LANG_CXX11
inline void updateBookBaseInfo::set_bookname(::std::string&& value) {
  set_has_bookname();
  bookname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.updateBookBaseInfo.bookName)
}
#endif
inline void updateBookBaseInfo::set_bookname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.updateBookBaseInfo.bookName)
}
inline void updateBookBaseInfo::set_bookname(const char* value, size_t size) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.updateBookBaseInfo.bookName)
}
inline ::std::string* updateBookBaseInfo::mutable_bookname() {
  set_has_bookname();
  // @@protoc_insertion_point(field_mutable:bookCityService.updateBookBaseInfo.bookName)
  return bookname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* updateBookBaseInfo::release_bookname() {
  // @@protoc_insertion_point(field_release:bookCityService.updateBookBaseInfo.bookName)
  if (!has_bookname()) {
    return NULL;
  }
  clear_has_bookname();
  return bookname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void updateBookBaseInfo::set_allocated_bookname(::std::string* bookname) {
  if (bookname != NULL) {
    set_has_bookname();
  } else {
    clear_has_bookname();
  }
  bookname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.updateBookBaseInfo.bookName)
}

// optional string authorName = 2;
inline bool updateBookBaseInfo::has_authorname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void updateBookBaseInfo::set_has_authorname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void updateBookBaseInfo::clear_has_authorname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void updateBookBaseInfo::clear_authorname() {
  authorname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authorname();
}
inline const ::std::string& updateBookBaseInfo::authorname() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.authorName)
  return authorname_.GetNoArena();
}
inline void updateBookBaseInfo::set_authorname(const ::std::string& value) {
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.authorName)
}
#if LANG_CXX11
inline void updateBookBaseInfo::set_authorname(::std::string&& value) {
  set_has_authorname();
  authorname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.updateBookBaseInfo.authorName)
}
#endif
inline void updateBookBaseInfo::set_authorname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.updateBookBaseInfo.authorName)
}
inline void updateBookBaseInfo::set_authorname(const char* value, size_t size) {
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.updateBookBaseInfo.authorName)
}
inline ::std::string* updateBookBaseInfo::mutable_authorname() {
  set_has_authorname();
  // @@protoc_insertion_point(field_mutable:bookCityService.updateBookBaseInfo.authorName)
  return authorname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* updateBookBaseInfo::release_authorname() {
  // @@protoc_insertion_point(field_release:bookCityService.updateBookBaseInfo.authorName)
  if (!has_authorname()) {
    return NULL;
  }
  clear_has_authorname();
  return authorname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void updateBookBaseInfo::set_allocated_authorname(::std::string* authorname) {
  if (authorname != NULL) {
    set_has_authorname();
  } else {
    clear_has_authorname();
  }
  authorname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authorname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.updateBookBaseInfo.authorName)
}

// optional int32 bookType = 3;
inline bool updateBookBaseInfo::has_booktype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void updateBookBaseInfo::set_has_booktype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void updateBookBaseInfo::clear_has_booktype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void updateBookBaseInfo::clear_booktype() {
  booktype_ = 0;
  clear_has_booktype();
}
inline ::google::protobuf::int32 updateBookBaseInfo::booktype() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.bookType)
  return booktype_;
}
inline void updateBookBaseInfo::set_booktype(::google::protobuf::int32 value) {
  set_has_booktype();
  booktype_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.bookType)
}

// optional string publishTime = 4;
inline bool updateBookBaseInfo::has_publishtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void updateBookBaseInfo::set_has_publishtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void updateBookBaseInfo::clear_has_publishtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void updateBookBaseInfo::clear_publishtime() {
  publishtime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_publishtime();
}
inline const ::std::string& updateBookBaseInfo::publishtime() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.publishTime)
  return publishtime_.GetNoArena();
}
inline void updateBookBaseInfo::set_publishtime(const ::std::string& value) {
  set_has_publishtime();
  publishtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.publishTime)
}
#if LANG_CXX11
inline void updateBookBaseInfo::set_publishtime(::std::string&& value) {
  set_has_publishtime();
  publishtime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.updateBookBaseInfo.publishTime)
}
#endif
inline void updateBookBaseInfo::set_publishtime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_publishtime();
  publishtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.updateBookBaseInfo.publishTime)
}
inline void updateBookBaseInfo::set_publishtime(const char* value, size_t size) {
  set_has_publishtime();
  publishtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.updateBookBaseInfo.publishTime)
}
inline ::std::string* updateBookBaseInfo::mutable_publishtime() {
  set_has_publishtime();
  // @@protoc_insertion_point(field_mutable:bookCityService.updateBookBaseInfo.publishTime)
  return publishtime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* updateBookBaseInfo::release_publishtime() {
  // @@protoc_insertion_point(field_release:bookCityService.updateBookBaseInfo.publishTime)
  if (!has_publishtime()) {
    return NULL;
  }
  clear_has_publishtime();
  return publishtime_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void updateBookBaseInfo::set_allocated_publishtime(::std::string* publishtime) {
  if (publishtime != NULL) {
    set_has_publishtime();
  } else {
    clear_has_publishtime();
  }
  publishtime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publishtime);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.updateBookBaseInfo.publishTime)
}

// optional string publishHouse = 5;
inline bool updateBookBaseInfo::has_publishhouse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void updateBookBaseInfo::set_has_publishhouse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void updateBookBaseInfo::clear_has_publishhouse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void updateBookBaseInfo::clear_publishhouse() {
  publishhouse_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_publishhouse();
}
inline const ::std::string& updateBookBaseInfo::publishhouse() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.publishHouse)
  return publishhouse_.GetNoArena();
}
inline void updateBookBaseInfo::set_publishhouse(const ::std::string& value) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.publishHouse)
}
#if LANG_CXX11
inline void updateBookBaseInfo::set_publishhouse(::std::string&& value) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.updateBookBaseInfo.publishHouse)
}
#endif
inline void updateBookBaseInfo::set_publishhouse(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.updateBookBaseInfo.publishHouse)
}
inline void updateBookBaseInfo::set_publishhouse(const char* value, size_t size) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.updateBookBaseInfo.publishHouse)
}
inline ::std::string* updateBookBaseInfo::mutable_publishhouse() {
  set_has_publishhouse();
  // @@protoc_insertion_point(field_mutable:bookCityService.updateBookBaseInfo.publishHouse)
  return publishhouse_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* updateBookBaseInfo::release_publishhouse() {
  // @@protoc_insertion_point(field_release:bookCityService.updateBookBaseInfo.publishHouse)
  if (!has_publishhouse()) {
    return NULL;
  }
  clear_has_publishhouse();
  return publishhouse_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void updateBookBaseInfo::set_allocated_publishhouse(::std::string* publishhouse) {
  if (publishhouse != NULL) {
    set_has_publishhouse();
  } else {
    clear_has_publishhouse();
  }
  publishhouse_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publishhouse);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.updateBookBaseInfo.publishHouse)
}

// optional string bookIntro = 6;
inline bool updateBookBaseInfo::has_bookintro() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void updateBookBaseInfo::set_has_bookintro() {
  _has_bits_[0] |= 0x00000010u;
}
inline void updateBookBaseInfo::clear_has_bookintro() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void updateBookBaseInfo::clear_bookintro() {
  bookintro_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookintro();
}
inline const ::std::string& updateBookBaseInfo::bookintro() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.bookIntro)
  return bookintro_.GetNoArena();
}
inline void updateBookBaseInfo::set_bookintro(const ::std::string& value) {
  set_has_bookintro();
  bookintro_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.bookIntro)
}
#if LANG_CXX11
inline void updateBookBaseInfo::set_bookintro(::std::string&& value) {
  set_has_bookintro();
  bookintro_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.updateBookBaseInfo.bookIntro)
}
#endif
inline void updateBookBaseInfo::set_bookintro(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookintro();
  bookintro_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.updateBookBaseInfo.bookIntro)
}
inline void updateBookBaseInfo::set_bookintro(const char* value, size_t size) {
  set_has_bookintro();
  bookintro_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.updateBookBaseInfo.bookIntro)
}
inline ::std::string* updateBookBaseInfo::mutable_bookintro() {
  set_has_bookintro();
  // @@protoc_insertion_point(field_mutable:bookCityService.updateBookBaseInfo.bookIntro)
  return bookintro_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* updateBookBaseInfo::release_bookintro() {
  // @@protoc_insertion_point(field_release:bookCityService.updateBookBaseInfo.bookIntro)
  if (!has_bookintro()) {
    return NULL;
  }
  clear_has_bookintro();
  return bookintro_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void updateBookBaseInfo::set_allocated_bookintro(::std::string* bookintro) {
  if (bookintro != NULL) {
    set_has_bookintro();
  } else {
    clear_has_bookintro();
  }
  bookintro_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookintro);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.updateBookBaseInfo.bookIntro)
}

// optional int32 bookPage = 7;
inline bool updateBookBaseInfo::has_bookpage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void updateBookBaseInfo::set_has_bookpage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void updateBookBaseInfo::clear_has_bookpage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void updateBookBaseInfo::clear_bookpage() {
  bookpage_ = 0;
  clear_has_bookpage();
}
inline ::google::protobuf::int32 updateBookBaseInfo::bookpage() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.bookPage)
  return bookpage_;
}
inline void updateBookBaseInfo::set_bookpage(::google::protobuf::int32 value) {
  set_has_bookpage();
  bookpage_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.bookPage)
}

// optional int32 languageType = 8;
inline bool updateBookBaseInfo::has_languagetype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void updateBookBaseInfo::set_has_languagetype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void updateBookBaseInfo::clear_has_languagetype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void updateBookBaseInfo::clear_languagetype() {
  languagetype_ = 0;
  clear_has_languagetype();
}
inline ::google::protobuf::int32 updateBookBaseInfo::languagetype() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.languageType)
  return languagetype_;
}
inline void updateBookBaseInfo::set_languagetype(::google::protobuf::int32 value) {
  set_has_languagetype();
  languagetype_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.languageType)
}

// required string bookId = 9;
inline bool updateBookBaseInfo::has_bookid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void updateBookBaseInfo::set_has_bookid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void updateBookBaseInfo::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void updateBookBaseInfo::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& updateBookBaseInfo::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.updateBookBaseInfo.bookId)
  return bookid_.GetNoArena();
}
inline void updateBookBaseInfo::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.updateBookBaseInfo.bookId)
}
#if LANG_CXX11
inline void updateBookBaseInfo::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.updateBookBaseInfo.bookId)
}
#endif
inline void updateBookBaseInfo::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.updateBookBaseInfo.bookId)
}
inline void updateBookBaseInfo::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.updateBookBaseInfo.bookId)
}
inline ::std::string* updateBookBaseInfo::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.updateBookBaseInfo.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* updateBookBaseInfo::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.updateBookBaseInfo.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void updateBookBaseInfo::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.updateBookBaseInfo.bookId)
}

// -------------------------------------------------------------------

// bookDownInfo

// required int32 fileSize = 1;
inline bool bookDownInfo::has_filesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bookDownInfo::set_has_filesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bookDownInfo::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bookDownInfo::clear_filesize() {
  filesize_ = 0;
  clear_has_filesize();
}
inline ::google::protobuf::int32 bookDownInfo::filesize() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookDownInfo.fileSize)
  return filesize_;
}
inline void bookDownInfo::set_filesize(::google::protobuf::int32 value) {
  set_has_filesize();
  filesize_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.bookDownInfo.fileSize)
}

// required string bookHeadUrl = 2;
inline bool bookDownInfo::has_bookheadurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bookDownInfo::set_has_bookheadurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bookDownInfo::clear_has_bookheadurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bookDownInfo::clear_bookheadurl() {
  bookheadurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookheadurl();
}
inline const ::std::string& bookDownInfo::bookheadurl() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookDownInfo.bookHeadUrl)
  return bookheadurl_.GetNoArena();
}
inline void bookDownInfo::set_bookheadurl(const ::std::string& value) {
  set_has_bookheadurl();
  bookheadurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookDownInfo.bookHeadUrl)
}
#if LANG_CXX11
inline void bookDownInfo::set_bookheadurl(::std::string&& value) {
  set_has_bookheadurl();
  bookheadurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookDownInfo.bookHeadUrl)
}
#endif
inline void bookDownInfo::set_bookheadurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookheadurl();
  bookheadurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookDownInfo.bookHeadUrl)
}
inline void bookDownInfo::set_bookheadurl(const char* value, size_t size) {
  set_has_bookheadurl();
  bookheadurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookDownInfo.bookHeadUrl)
}
inline ::std::string* bookDownInfo::mutable_bookheadurl() {
  set_has_bookheadurl();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookDownInfo.bookHeadUrl)
  return bookheadurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookDownInfo::release_bookheadurl() {
  // @@protoc_insertion_point(field_release:bookCityService.bookDownInfo.bookHeadUrl)
  if (!has_bookheadurl()) {
    return NULL;
  }
  clear_has_bookheadurl();
  return bookheadurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookDownInfo::set_allocated_bookheadurl(::std::string* bookheadurl) {
  if (bookheadurl != NULL) {
    set_has_bookheadurl();
  } else {
    clear_has_bookheadurl();
  }
  bookheadurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookheadurl);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookDownInfo.bookHeadUrl)
}

// required string bookDownUrl = 3;
inline bool bookDownInfo::has_bookdownurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bookDownInfo::set_has_bookdownurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bookDownInfo::clear_has_bookdownurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bookDownInfo::clear_bookdownurl() {
  bookdownurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookdownurl();
}
inline const ::std::string& bookDownInfo::bookdownurl() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookDownInfo.bookDownUrl)
  return bookdownurl_.GetNoArena();
}
inline void bookDownInfo::set_bookdownurl(const ::std::string& value) {
  set_has_bookdownurl();
  bookdownurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookDownInfo.bookDownUrl)
}
#if LANG_CXX11
inline void bookDownInfo::set_bookdownurl(::std::string&& value) {
  set_has_bookdownurl();
  bookdownurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookDownInfo.bookDownUrl)
}
#endif
inline void bookDownInfo::set_bookdownurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookdownurl();
  bookdownurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookDownInfo.bookDownUrl)
}
inline void bookDownInfo::set_bookdownurl(const char* value, size_t size) {
  set_has_bookdownurl();
  bookdownurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookDownInfo.bookDownUrl)
}
inline ::std::string* bookDownInfo::mutable_bookdownurl() {
  set_has_bookdownurl();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookDownInfo.bookDownUrl)
  return bookdownurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookDownInfo::release_bookdownurl() {
  // @@protoc_insertion_point(field_release:bookCityService.bookDownInfo.bookDownUrl)
  if (!has_bookdownurl()) {
    return NULL;
  }
  clear_has_bookdownurl();
  return bookdownurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookDownInfo::set_allocated_bookdownurl(::std::string* bookdownurl) {
  if (bookdownurl != NULL) {
    set_has_bookdownurl();
  } else {
    clear_has_bookdownurl();
  }
  bookdownurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookdownurl);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookDownInfo.bookDownUrl)
}

// -------------------------------------------------------------------

// bookGradeInfo

// required int32 remarkCount = 1;
inline bool bookGradeInfo::has_remarkcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bookGradeInfo::set_has_remarkcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bookGradeInfo::clear_has_remarkcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bookGradeInfo::clear_remarkcount() {
  remarkcount_ = 0;
  clear_has_remarkcount();
}
inline ::google::protobuf::int32 bookGradeInfo::remarkcount() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookGradeInfo.remarkCount)
  return remarkcount_;
}
inline void bookGradeInfo::set_remarkcount(::google::protobuf::int32 value) {
  set_has_remarkcount();
  remarkcount_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.bookGradeInfo.remarkCount)
}

// required float averageScore = 2;
inline bool bookGradeInfo::has_averagescore() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bookGradeInfo::set_has_averagescore() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bookGradeInfo::clear_has_averagescore() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bookGradeInfo::clear_averagescore() {
  averagescore_ = 0;
  clear_has_averagescore();
}
inline float bookGradeInfo::averagescore() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookGradeInfo.averageScore)
  return averagescore_;
}
inline void bookGradeInfo::set_averagescore(float value) {
  set_has_averagescore();
  averagescore_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.bookGradeInfo.averageScore)
}

// -------------------------------------------------------------------

// boocomCombinekInfo

// required string bookId = 1;
inline bool boocomCombinekInfo::has_bookid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boocomCombinekInfo::set_has_bookid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boocomCombinekInfo::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boocomCombinekInfo::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& boocomCombinekInfo::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.boocomCombinekInfo.bookId)
  return bookid_.GetNoArena();
}
inline void boocomCombinekInfo::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.boocomCombinekInfo.bookId)
}
#if LANG_CXX11
inline void boocomCombinekInfo::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.boocomCombinekInfo.bookId)
}
#endif
inline void boocomCombinekInfo::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.boocomCombinekInfo.bookId)
}
inline void boocomCombinekInfo::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.boocomCombinekInfo.bookId)
}
inline ::std::string* boocomCombinekInfo::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.boocomCombinekInfo.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* boocomCombinekInfo::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.boocomCombinekInfo.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void boocomCombinekInfo::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.boocomCombinekInfo.bookId)
}

// required .bookCityService.bookBaseInfo baseInfo = 2;
inline bool boocomCombinekInfo::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boocomCombinekInfo::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boocomCombinekInfo::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boocomCombinekInfo::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->Clear();
  clear_has_baseinfo();
}
inline const ::bookCityService::bookBaseInfo& boocomCombinekInfo::_internal_baseinfo() const {
  return *baseinfo_;
}
inline const ::bookCityService::bookBaseInfo& boocomCombinekInfo::baseinfo() const {
  const ::bookCityService::bookBaseInfo* p = baseinfo_;
  // @@protoc_insertion_point(field_get:bookCityService.boocomCombinekInfo.baseInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::bookCityService::bookBaseInfo*>(
      &::bookCityService::_bookBaseInfo_default_instance_);
}
inline ::bookCityService::bookBaseInfo* boocomCombinekInfo::release_baseinfo() {
  // @@protoc_insertion_point(field_release:bookCityService.boocomCombinekInfo.baseInfo)
  clear_has_baseinfo();
  ::bookCityService::bookBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline ::bookCityService::bookBaseInfo* boocomCombinekInfo::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::bookCityService::bookBaseInfo>(GetArenaNoVirtual());
    baseinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bookCityService.boocomCombinekInfo.baseInfo)
  return baseinfo_;
}
inline void boocomCombinekInfo::set_allocated_baseinfo(::bookCityService::bookBaseInfo* baseinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete baseinfo_;
  }
  if (baseinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      baseinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:bookCityService.boocomCombinekInfo.baseInfo)
}

// required .bookCityService.bookDownInfo downInfo = 3;
inline bool boocomCombinekInfo::has_downinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boocomCombinekInfo::set_has_downinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boocomCombinekInfo::clear_has_downinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boocomCombinekInfo::clear_downinfo() {
  if (downinfo_ != NULL) downinfo_->Clear();
  clear_has_downinfo();
}
inline const ::bookCityService::bookDownInfo& boocomCombinekInfo::_internal_downinfo() const {
  return *downinfo_;
}
inline const ::bookCityService::bookDownInfo& boocomCombinekInfo::downinfo() const {
  const ::bookCityService::bookDownInfo* p = downinfo_;
  // @@protoc_insertion_point(field_get:bookCityService.boocomCombinekInfo.downInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::bookCityService::bookDownInfo*>(
      &::bookCityService::_bookDownInfo_default_instance_);
}
inline ::bookCityService::bookDownInfo* boocomCombinekInfo::release_downinfo() {
  // @@protoc_insertion_point(field_release:bookCityService.boocomCombinekInfo.downInfo)
  clear_has_downinfo();
  ::bookCityService::bookDownInfo* temp = downinfo_;
  downinfo_ = NULL;
  return temp;
}
inline ::bookCityService::bookDownInfo* boocomCombinekInfo::mutable_downinfo() {
  set_has_downinfo();
  if (downinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::bookCityService::bookDownInfo>(GetArenaNoVirtual());
    downinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bookCityService.boocomCombinekInfo.downInfo)
  return downinfo_;
}
inline void boocomCombinekInfo::set_allocated_downinfo(::bookCityService::bookDownInfo* downinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete downinfo_;
  }
  if (downinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      downinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, downinfo, submessage_arena);
    }
    set_has_downinfo();
  } else {
    clear_has_downinfo();
  }
  downinfo_ = downinfo;
  // @@protoc_insertion_point(field_set_allocated:bookCityService.boocomCombinekInfo.downInfo)
}

// required .bookCityService.bookGradeInfo gradeInfo = 4;
inline bool boocomCombinekInfo::has_gradeinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boocomCombinekInfo::set_has_gradeinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boocomCombinekInfo::clear_has_gradeinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boocomCombinekInfo::clear_gradeinfo() {
  if (gradeinfo_ != NULL) gradeinfo_->Clear();
  clear_has_gradeinfo();
}
inline const ::bookCityService::bookGradeInfo& boocomCombinekInfo::_internal_gradeinfo() const {
  return *gradeinfo_;
}
inline const ::bookCityService::bookGradeInfo& boocomCombinekInfo::gradeinfo() const {
  const ::bookCityService::bookGradeInfo* p = gradeinfo_;
  // @@protoc_insertion_point(field_get:bookCityService.boocomCombinekInfo.gradeInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::bookCityService::bookGradeInfo*>(
      &::bookCityService::_bookGradeInfo_default_instance_);
}
inline ::bookCityService::bookGradeInfo* boocomCombinekInfo::release_gradeinfo() {
  // @@protoc_insertion_point(field_release:bookCityService.boocomCombinekInfo.gradeInfo)
  clear_has_gradeinfo();
  ::bookCityService::bookGradeInfo* temp = gradeinfo_;
  gradeinfo_ = NULL;
  return temp;
}
inline ::bookCityService::bookGradeInfo* boocomCombinekInfo::mutable_gradeinfo() {
  set_has_gradeinfo();
  if (gradeinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::bookCityService::bookGradeInfo>(GetArenaNoVirtual());
    gradeinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bookCityService.boocomCombinekInfo.gradeInfo)
  return gradeinfo_;
}
inline void boocomCombinekInfo::set_allocated_gradeinfo(::bookCityService::bookGradeInfo* gradeinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gradeinfo_;
  }
  if (gradeinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gradeinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gradeinfo, submessage_arena);
    }
    set_has_gradeinfo();
  } else {
    clear_has_gradeinfo();
  }
  gradeinfo_ = gradeinfo;
  // @@protoc_insertion_point(field_set_allocated:bookCityService.boocomCombinekInfo.gradeInfo)
}

// -------------------------------------------------------------------

// bookMarkItem

// required string bookId = 1;
inline bool bookMarkItem::has_bookid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bookMarkItem::set_has_bookid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bookMarkItem::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bookMarkItem::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& bookMarkItem::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.bookMarkItem.bookId)
  return bookid_.GetNoArena();
}
inline void bookMarkItem::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.bookMarkItem.bookId)
}
#if LANG_CXX11
inline void bookMarkItem::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.bookMarkItem.bookId)
}
#endif
inline void bookMarkItem::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.bookMarkItem.bookId)
}
inline void bookMarkItem::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.bookMarkItem.bookId)
}
inline ::std::string* bookMarkItem::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.bookMarkItem.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bookMarkItem::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.bookMarkItem.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bookMarkItem::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.bookMarkItem.bookId)
}

// -------------------------------------------------------------------

// getAllBookInfoReq

// optional int32 offset = 1;
inline bool getAllBookInfoReq::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getAllBookInfoReq::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getAllBookInfoReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getAllBookInfoReq::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 getAllBookInfoReq::offset() const {
  // @@protoc_insertion_point(field_get:bookCityService.getAllBookInfoReq.offset)
  return offset_;
}
inline void getAllBookInfoReq::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.getAllBookInfoReq.offset)
}

// optional int32 size = 2;
inline bool getAllBookInfoReq::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getAllBookInfoReq::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getAllBookInfoReq::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getAllBookInfoReq::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 getAllBookInfoReq::size() const {
  // @@protoc_insertion_point(field_get:bookCityService.getAllBookInfoReq.size)
  return size_;
}
inline void getAllBookInfoReq::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.getAllBookInfoReq.size)
}

// -------------------------------------------------------------------

// searchBookReq

// optional int32 userId = 1;
inline bool searchBookReq::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void searchBookReq::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void searchBookReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void searchBookReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 searchBookReq::userid() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.userId)
  return userid_;
}
inline void searchBookReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.userId)
}

// optional string bookId = 2;
inline bool searchBookReq::has_bookid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void searchBookReq::set_has_bookid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void searchBookReq::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void searchBookReq::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& searchBookReq::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.bookId)
  return bookid_.GetNoArena();
}
inline void searchBookReq::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.bookId)
}
#if LANG_CXX11
inline void searchBookReq::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.searchBookReq.bookId)
}
#endif
inline void searchBookReq::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.searchBookReq.bookId)
}
inline void searchBookReq::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.searchBookReq.bookId)
}
inline ::std::string* searchBookReq::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.searchBookReq.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* searchBookReq::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.searchBookReq.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void searchBookReq::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.searchBookReq.bookId)
}

// optional string bookName = 3;
inline bool searchBookReq::has_bookname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void searchBookReq::set_has_bookname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void searchBookReq::clear_has_bookname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void searchBookReq::clear_bookname() {
  bookname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookname();
}
inline const ::std::string& searchBookReq::bookname() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.bookName)
  return bookname_.GetNoArena();
}
inline void searchBookReq::set_bookname(const ::std::string& value) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.bookName)
}
#if LANG_CXX11
inline void searchBookReq::set_bookname(::std::string&& value) {
  set_has_bookname();
  bookname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.searchBookReq.bookName)
}
#endif
inline void searchBookReq::set_bookname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.searchBookReq.bookName)
}
inline void searchBookReq::set_bookname(const char* value, size_t size) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.searchBookReq.bookName)
}
inline ::std::string* searchBookReq::mutable_bookname() {
  set_has_bookname();
  // @@protoc_insertion_point(field_mutable:bookCityService.searchBookReq.bookName)
  return bookname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* searchBookReq::release_bookname() {
  // @@protoc_insertion_point(field_release:bookCityService.searchBookReq.bookName)
  if (!has_bookname()) {
    return NULL;
  }
  clear_has_bookname();
  return bookname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void searchBookReq::set_allocated_bookname(::std::string* bookname) {
  if (bookname != NULL) {
    set_has_bookname();
  } else {
    clear_has_bookname();
  }
  bookname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.searchBookReq.bookName)
}

// optional string authorName = 4;
inline bool searchBookReq::has_authorname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void searchBookReq::set_has_authorname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void searchBookReq::clear_has_authorname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void searchBookReq::clear_authorname() {
  authorname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authorname();
}
inline const ::std::string& searchBookReq::authorname() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.authorName)
  return authorname_.GetNoArena();
}
inline void searchBookReq::set_authorname(const ::std::string& value) {
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.authorName)
}
#if LANG_CXX11
inline void searchBookReq::set_authorname(::std::string&& value) {
  set_has_authorname();
  authorname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.searchBookReq.authorName)
}
#endif
inline void searchBookReq::set_authorname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.searchBookReq.authorName)
}
inline void searchBookReq::set_authorname(const char* value, size_t size) {
  set_has_authorname();
  authorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.searchBookReq.authorName)
}
inline ::std::string* searchBookReq::mutable_authorname() {
  set_has_authorname();
  // @@protoc_insertion_point(field_mutable:bookCityService.searchBookReq.authorName)
  return authorname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* searchBookReq::release_authorname() {
  // @@protoc_insertion_point(field_release:bookCityService.searchBookReq.authorName)
  if (!has_authorname()) {
    return NULL;
  }
  clear_has_authorname();
  return authorname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void searchBookReq::set_allocated_authorname(::std::string* authorname) {
  if (authorname != NULL) {
    set_has_authorname();
  } else {
    clear_has_authorname();
  }
  authorname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authorname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.searchBookReq.authorName)
}

// optional int32 bookType = 5;
inline bool searchBookReq::has_booktype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void searchBookReq::set_has_booktype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void searchBookReq::clear_has_booktype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void searchBookReq::clear_booktype() {
  booktype_ = 0;
  clear_has_booktype();
}
inline ::google::protobuf::int32 searchBookReq::booktype() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.bookType)
  return booktype_;
}
inline void searchBookReq::set_booktype(::google::protobuf::int32 value) {
  set_has_booktype();
  booktype_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.bookType)
}

// optional string publishHouse = 6;
inline bool searchBookReq::has_publishhouse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void searchBookReq::set_has_publishhouse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void searchBookReq::clear_has_publishhouse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void searchBookReq::clear_publishhouse() {
  publishhouse_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_publishhouse();
}
inline const ::std::string& searchBookReq::publishhouse() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.publishHouse)
  return publishhouse_.GetNoArena();
}
inline void searchBookReq::set_publishhouse(const ::std::string& value) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.publishHouse)
}
#if LANG_CXX11
inline void searchBookReq::set_publishhouse(::std::string&& value) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.searchBookReq.publishHouse)
}
#endif
inline void searchBookReq::set_publishhouse(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.searchBookReq.publishHouse)
}
inline void searchBookReq::set_publishhouse(const char* value, size_t size) {
  set_has_publishhouse();
  publishhouse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.searchBookReq.publishHouse)
}
inline ::std::string* searchBookReq::mutable_publishhouse() {
  set_has_publishhouse();
  // @@protoc_insertion_point(field_mutable:bookCityService.searchBookReq.publishHouse)
  return publishhouse_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* searchBookReq::release_publishhouse() {
  // @@protoc_insertion_point(field_release:bookCityService.searchBookReq.publishHouse)
  if (!has_publishhouse()) {
    return NULL;
  }
  clear_has_publishhouse();
  return publishhouse_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void searchBookReq::set_allocated_publishhouse(::std::string* publishhouse) {
  if (publishhouse != NULL) {
    set_has_publishhouse();
  } else {
    clear_has_publishhouse();
  }
  publishhouse_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publishhouse);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.searchBookReq.publishHouse)
}

// required string dayTime = 7;
inline bool searchBookReq::has_daytime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void searchBookReq::set_has_daytime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void searchBookReq::clear_has_daytime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void searchBookReq::clear_daytime() {
  daytime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_daytime();
}
inline const ::std::string& searchBookReq::daytime() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.dayTime)
  return daytime_.GetNoArena();
}
inline void searchBookReq::set_daytime(const ::std::string& value) {
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.dayTime)
}
#if LANG_CXX11
inline void searchBookReq::set_daytime(::std::string&& value) {
  set_has_daytime();
  daytime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.searchBookReq.dayTime)
}
#endif
inline void searchBookReq::set_daytime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.searchBookReq.dayTime)
}
inline void searchBookReq::set_daytime(const char* value, size_t size) {
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.searchBookReq.dayTime)
}
inline ::std::string* searchBookReq::mutable_daytime() {
  set_has_daytime();
  // @@protoc_insertion_point(field_mutable:bookCityService.searchBookReq.dayTime)
  return daytime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* searchBookReq::release_daytime() {
  // @@protoc_insertion_point(field_release:bookCityService.searchBookReq.dayTime)
  if (!has_daytime()) {
    return NULL;
  }
  clear_has_daytime();
  return daytime_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void searchBookReq::set_allocated_daytime(::std::string* daytime) {
  if (daytime != NULL) {
    set_has_daytime();
  } else {
    clear_has_daytime();
  }
  daytime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), daytime);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.searchBookReq.dayTime)
}

// required int32 offset = 8;
inline bool searchBookReq::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void searchBookReq::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void searchBookReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void searchBookReq::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 searchBookReq::offset() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.offset)
  return offset_;
}
inline void searchBookReq::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.offset)
}

// required int32 count = 9;
inline bool searchBookReq::has_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void searchBookReq::set_has_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void searchBookReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void searchBookReq::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 searchBookReq::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.searchBookReq.count)
  return count_;
}
inline void searchBookReq::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.searchBookReq.count)
}

// -------------------------------------------------------------------

// booksRespList

// optional string userId = 1;
inline bool booksRespList::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void booksRespList::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void booksRespList::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void booksRespList::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& booksRespList::userid() const {
  // @@protoc_insertion_point(field_get:bookCityService.booksRespList.userId)
  return userid_.GetNoArena();
}
inline void booksRespList::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.booksRespList.userId)
}
#if LANG_CXX11
inline void booksRespList::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.booksRespList.userId)
}
#endif
inline void booksRespList::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.booksRespList.userId)
}
inline void booksRespList::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.booksRespList.userId)
}
inline ::std::string* booksRespList::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:bookCityService.booksRespList.userId)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* booksRespList::release_userid() {
  // @@protoc_insertion_point(field_release:bookCityService.booksRespList.userId)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void booksRespList::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.booksRespList.userId)
}

// repeated .bookCityService.boocomCombinekInfo lists = 2;
inline int booksRespList::lists_size() const {
  return lists_.size();
}
inline void booksRespList::clear_lists() {
  lists_.Clear();
}
inline ::bookCityService::boocomCombinekInfo* booksRespList::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:bookCityService.booksRespList.lists)
  return lists_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
booksRespList::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:bookCityService.booksRespList.lists)
  return &lists_;
}
inline const ::bookCityService::boocomCombinekInfo& booksRespList::lists(int index) const {
  // @@protoc_insertion_point(field_get:bookCityService.booksRespList.lists)
  return lists_.Get(index);
}
inline ::bookCityService::boocomCombinekInfo* booksRespList::add_lists() {
  // @@protoc_insertion_point(field_add:bookCityService.booksRespList.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
booksRespList::lists() const {
  // @@protoc_insertion_point(field_list:bookCityService.booksRespList.lists)
  return lists_;
}

// required int32 count = 3;
inline bool booksRespList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void booksRespList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void booksRespList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void booksRespList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 booksRespList::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.booksRespList.count)
  return count_;
}
inline void booksRespList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.booksRespList.count)
}

// -------------------------------------------------------------------

// getBookTypeReq

// optional string userId = 1;
inline bool getBookTypeReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getBookTypeReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getBookTypeReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getBookTypeReq::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& getBookTypeReq::userid() const {
  // @@protoc_insertion_point(field_get:bookCityService.getBookTypeReq.userId)
  return userid_.GetNoArena();
}
inline void getBookTypeReq::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.getBookTypeReq.userId)
}
#if LANG_CXX11
inline void getBookTypeReq::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.getBookTypeReq.userId)
}
#endif
inline void getBookTypeReq::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.getBookTypeReq.userId)
}
inline void getBookTypeReq::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.getBookTypeReq.userId)
}
inline ::std::string* getBookTypeReq::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:bookCityService.getBookTypeReq.userId)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* getBookTypeReq::release_userid() {
  // @@protoc_insertion_point(field_release:bookCityService.getBookTypeReq.userId)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void getBookTypeReq::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.getBookTypeReq.userId)
}

// required string type = 2;
inline bool getBookTypeReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getBookTypeReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getBookTypeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getBookTypeReq::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& getBookTypeReq::type() const {
  // @@protoc_insertion_point(field_get:bookCityService.getBookTypeReq.type)
  return type_.GetNoArena();
}
inline void getBookTypeReq::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.getBookTypeReq.type)
}
#if LANG_CXX11
inline void getBookTypeReq::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.getBookTypeReq.type)
}
#endif
inline void getBookTypeReq::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.getBookTypeReq.type)
}
inline void getBookTypeReq::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.getBookTypeReq.type)
}
inline ::std::string* getBookTypeReq::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:bookCityService.getBookTypeReq.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* getBookTypeReq::release_type() {
  // @@protoc_insertion_point(field_release:bookCityService.getBookTypeReq.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void getBookTypeReq::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.getBookTypeReq.type)
}

// optional int32 offset = 3;
inline bool getBookTypeReq::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getBookTypeReq::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getBookTypeReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getBookTypeReq::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 getBookTypeReq::offset() const {
  // @@protoc_insertion_point(field_get:bookCityService.getBookTypeReq.offset)
  return offset_;
}
inline void getBookTypeReq::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.getBookTypeReq.offset)
}

// required int32 count = 4;
inline bool getBookTypeReq::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void getBookTypeReq::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void getBookTypeReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void getBookTypeReq::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 getBookTypeReq::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.getBookTypeReq.count)
  return count_;
}
inline void getBookTypeReq::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.getBookTypeReq.count)
}

// optional int32 sortMethod = 5;
inline bool getBookTypeReq::has_sortmethod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void getBookTypeReq::set_has_sortmethod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void getBookTypeReq::clear_has_sortmethod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void getBookTypeReq::clear_sortmethod() {
  sortmethod_ = 0;
  clear_has_sortmethod();
}
inline ::google::protobuf::int32 getBookTypeReq::sortmethod() const {
  // @@protoc_insertion_point(field_get:bookCityService.getBookTypeReq.sortMethod)
  return sortmethod_;
}
inline void getBookTypeReq::set_sortmethod(::google::protobuf::int32 value) {
  set_has_sortmethod();
  sortmethod_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.getBookTypeReq.sortMethod)
}

// -------------------------------------------------------------------

// delBookReq

// required string userId = 1;
inline bool delBookReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void delBookReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void delBookReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void delBookReq::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& delBookReq::userid() const {
  // @@protoc_insertion_point(field_get:bookCityService.delBookReq.userId)
  return userid_.GetNoArena();
}
inline void delBookReq::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.delBookReq.userId)
}
#if LANG_CXX11
inline void delBookReq::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.delBookReq.userId)
}
#endif
inline void delBookReq::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.delBookReq.userId)
}
inline void delBookReq::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.delBookReq.userId)
}
inline ::std::string* delBookReq::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:bookCityService.delBookReq.userId)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* delBookReq::release_userid() {
  // @@protoc_insertion_point(field_release:bookCityService.delBookReq.userId)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void delBookReq::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.delBookReq.userId)
}

// required string bookId = 2;
inline bool delBookReq::has_bookid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void delBookReq::set_has_bookid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void delBookReq::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void delBookReq::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& delBookReq::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.delBookReq.bookId)
  return bookid_.GetNoArena();
}
inline void delBookReq::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.delBookReq.bookId)
}
#if LANG_CXX11
inline void delBookReq::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.delBookReq.bookId)
}
#endif
inline void delBookReq::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.delBookReq.bookId)
}
inline void delBookReq::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.delBookReq.bookId)
}
inline ::std::string* delBookReq::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.delBookReq.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* delBookReq::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.delBookReq.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void delBookReq::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.delBookReq.bookId)
}

// optional string delTime = 3;
inline bool delBookReq::has_deltime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void delBookReq::set_has_deltime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void delBookReq::clear_has_deltime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void delBookReq::clear_deltime() {
  deltime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deltime();
}
inline const ::std::string& delBookReq::deltime() const {
  // @@protoc_insertion_point(field_get:bookCityService.delBookReq.delTime)
  return deltime_.GetNoArena();
}
inline void delBookReq::set_deltime(const ::std::string& value) {
  set_has_deltime();
  deltime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.delBookReq.delTime)
}
#if LANG_CXX11
inline void delBookReq::set_deltime(::std::string&& value) {
  set_has_deltime();
  deltime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.delBookReq.delTime)
}
#endif
inline void delBookReq::set_deltime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deltime();
  deltime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.delBookReq.delTime)
}
inline void delBookReq::set_deltime(const char* value, size_t size) {
  set_has_deltime();
  deltime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.delBookReq.delTime)
}
inline ::std::string* delBookReq::mutable_deltime() {
  set_has_deltime();
  // @@protoc_insertion_point(field_mutable:bookCityService.delBookReq.delTime)
  return deltime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* delBookReq::release_deltime() {
  // @@protoc_insertion_point(field_release:bookCityService.delBookReq.delTime)
  if (!has_deltime()) {
    return NULL;
  }
  clear_has_deltime();
  return deltime_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void delBookReq::set_allocated_deltime(::std::string* deltime) {
  if (deltime != NULL) {
    set_has_deltime();
  } else {
    clear_has_deltime();
  }
  deltime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deltime);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.delBookReq.delTime)
}

// -------------------------------------------------------------------

// adsReq

// optional string bookId = 1;
inline bool adsReq::has_bookid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void adsReq::set_has_bookid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void adsReq::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void adsReq::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& adsReq::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.adsReq.bookId)
  return bookid_.GetNoArena();
}
inline void adsReq::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.adsReq.bookId)
}
#if LANG_CXX11
inline void adsReq::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.adsReq.bookId)
}
#endif
inline void adsReq::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.adsReq.bookId)
}
inline void adsReq::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.adsReq.bookId)
}
inline ::std::string* adsReq::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.adsReq.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* adsReq::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.adsReq.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void adsReq::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.adsReq.bookId)
}

// optional string adUrl = 2;
inline bool adsReq::has_adurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void adsReq::set_has_adurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void adsReq::clear_has_adurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void adsReq::clear_adurl() {
  adurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_adurl();
}
inline const ::std::string& adsReq::adurl() const {
  // @@protoc_insertion_point(field_get:bookCityService.adsReq.adUrl)
  return adurl_.GetNoArena();
}
inline void adsReq::set_adurl(const ::std::string& value) {
  set_has_adurl();
  adurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.adsReq.adUrl)
}
#if LANG_CXX11
inline void adsReq::set_adurl(::std::string&& value) {
  set_has_adurl();
  adurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.adsReq.adUrl)
}
#endif
inline void adsReq::set_adurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_adurl();
  adurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.adsReq.adUrl)
}
inline void adsReq::set_adurl(const char* value, size_t size) {
  set_has_adurl();
  adurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.adsReq.adUrl)
}
inline ::std::string* adsReq::mutable_adurl() {
  set_has_adurl();
  // @@protoc_insertion_point(field_mutable:bookCityService.adsReq.adUrl)
  return adurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* adsReq::release_adurl() {
  // @@protoc_insertion_point(field_release:bookCityService.adsReq.adUrl)
  if (!has_adurl()) {
    return NULL;
  }
  clear_has_adurl();
  return adurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void adsReq::set_allocated_adurl(::std::string* adurl) {
  if (adurl != NULL) {
    set_has_adurl();
  } else {
    clear_has_adurl();
  }
  adurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adurl);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.adsReq.adUrl)
}

// -------------------------------------------------------------------

// adInfo

// optional string adUrl = 1;
inline bool adInfo::has_adurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void adInfo::set_has_adurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void adInfo::clear_has_adurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void adInfo::clear_adurl() {
  adurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_adurl();
}
inline const ::std::string& adInfo::adurl() const {
  // @@protoc_insertion_point(field_get:bookCityService.adInfo.adUrl)
  return adurl_.GetNoArena();
}
inline void adInfo::set_adurl(const ::std::string& value) {
  set_has_adurl();
  adurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.adInfo.adUrl)
}
#if LANG_CXX11
inline void adInfo::set_adurl(::std::string&& value) {
  set_has_adurl();
  adurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.adInfo.adUrl)
}
#endif
inline void adInfo::set_adurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_adurl();
  adurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.adInfo.adUrl)
}
inline void adInfo::set_adurl(const char* value, size_t size) {
  set_has_adurl();
  adurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.adInfo.adUrl)
}
inline ::std::string* adInfo::mutable_adurl() {
  set_has_adurl();
  // @@protoc_insertion_point(field_mutable:bookCityService.adInfo.adUrl)
  return adurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* adInfo::release_adurl() {
  // @@protoc_insertion_point(field_release:bookCityService.adInfo.adUrl)
  if (!has_adurl()) {
    return NULL;
  }
  clear_has_adurl();
  return adurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void adInfo::set_allocated_adurl(::std::string* adurl) {
  if (adurl != NULL) {
    set_has_adurl();
  } else {
    clear_has_adurl();
  }
  adurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adurl);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.adInfo.adUrl)
}

// repeated .bookCityService.boocomCombinekInfo lists = 2;
inline int adInfo::lists_size() const {
  return lists_.size();
}
inline void adInfo::clear_lists() {
  lists_.Clear();
}
inline ::bookCityService::boocomCombinekInfo* adInfo::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:bookCityService.adInfo.lists)
  return lists_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
adInfo::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:bookCityService.adInfo.lists)
  return &lists_;
}
inline const ::bookCityService::boocomCombinekInfo& adInfo::lists(int index) const {
  // @@protoc_insertion_point(field_get:bookCityService.adInfo.lists)
  return lists_.Get(index);
}
inline ::bookCityService::boocomCombinekInfo* adInfo::add_lists() {
  // @@protoc_insertion_point(field_add:bookCityService.adInfo.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
adInfo::lists() const {
  // @@protoc_insertion_point(field_list:bookCityService.adInfo.lists)
  return lists_;
}

// -------------------------------------------------------------------

// adsRes

// repeated .bookCityService.adInfo lists = 1;
inline int adsRes::lists_size() const {
  return lists_.size();
}
inline void adsRes::clear_lists() {
  lists_.Clear();
}
inline ::bookCityService::adInfo* adsRes::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:bookCityService.adsRes.lists)
  return lists_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bookCityService::adInfo >*
adsRes::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:bookCityService.adsRes.lists)
  return &lists_;
}
inline const ::bookCityService::adInfo& adsRes::lists(int index) const {
  // @@protoc_insertion_point(field_get:bookCityService.adsRes.lists)
  return lists_.Get(index);
}
inline ::bookCityService::adInfo* adsRes::add_lists() {
  // @@protoc_insertion_point(field_add:bookCityService.adsRes.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bookCityService::adInfo >&
adsRes::lists() const {
  // @@protoc_insertion_point(field_list:bookCityService.adsRes.lists)
  return lists_;
}

// required int32 count = 2;
inline bool adsRes::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void adsRes::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void adsRes::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void adsRes::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 adsRes::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.adsRes.count)
  return count_;
}
inline void adsRes::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.adsRes.count)
}

// -------------------------------------------------------------------

// recommendBookReq

// required int32 userId = 1;
inline bool recommendBookReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recommendBookReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recommendBookReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recommendBookReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 recommendBookReq::userid() const {
  // @@protoc_insertion_point(field_get:bookCityService.recommendBookReq.userId)
  return userid_;
}
inline void recommendBookReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.recommendBookReq.userId)
}

// -------------------------------------------------------------------

// recommendBookRes

// repeated .bookCityService.boocomCombinekInfo lists = 1;
inline int recommendBookRes::lists_size() const {
  return lists_.size();
}
inline void recommendBookRes::clear_lists() {
  lists_.Clear();
}
inline ::bookCityService::boocomCombinekInfo* recommendBookRes::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:bookCityService.recommendBookRes.lists)
  return lists_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
recommendBookRes::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:bookCityService.recommendBookRes.lists)
  return &lists_;
}
inline const ::bookCityService::boocomCombinekInfo& recommendBookRes::lists(int index) const {
  // @@protoc_insertion_point(field_get:bookCityService.recommendBookRes.lists)
  return lists_.Get(index);
}
inline ::bookCityService::boocomCombinekInfo* recommendBookRes::add_lists() {
  // @@protoc_insertion_point(field_add:bookCityService.recommendBookRes.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
recommendBookRes::lists() const {
  // @@protoc_insertion_point(field_list:bookCityService.recommendBookRes.lists)
  return lists_;
}

// required int32 count = 2;
inline bool recommendBookRes::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recommendBookRes::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recommendBookRes::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recommendBookRes::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 recommendBookRes::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.recommendBookRes.count)
  return count_;
}
inline void recommendBookRes::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.recommendBookRes.count)
}

// -------------------------------------------------------------------

// browseBookReq

// required int32 userId = 1;
inline bool browseBookReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void browseBookReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void browseBookReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void browseBookReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 browseBookReq::userid() const {
  // @@protoc_insertion_point(field_get:bookCityService.browseBookReq.userId)
  return userid_;
}
inline void browseBookReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.browseBookReq.userId)
}

// -------------------------------------------------------------------

// browseBookRes

// repeated .bookCityService.boocomCombinekInfo lists = 1;
inline int browseBookRes::lists_size() const {
  return lists_.size();
}
inline void browseBookRes::clear_lists() {
  lists_.Clear();
}
inline ::bookCityService::boocomCombinekInfo* browseBookRes::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:bookCityService.browseBookRes.lists)
  return lists_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >*
browseBookRes::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:bookCityService.browseBookRes.lists)
  return &lists_;
}
inline const ::bookCityService::boocomCombinekInfo& browseBookRes::lists(int index) const {
  // @@protoc_insertion_point(field_get:bookCityService.browseBookRes.lists)
  return lists_.Get(index);
}
inline ::bookCityService::boocomCombinekInfo* browseBookRes::add_lists() {
  // @@protoc_insertion_point(field_add:bookCityService.browseBookRes.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bookCityService::boocomCombinekInfo >&
browseBookRes::lists() const {
  // @@protoc_insertion_point(field_list:bookCityService.browseBookRes.lists)
  return lists_;
}

// required int32 count = 2;
inline bool browseBookRes::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void browseBookRes::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void browseBookRes::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void browseBookRes::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 browseBookRes::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.browseBookRes.count)
  return count_;
}
inline void browseBookRes::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.browseBookRes.count)
}

// -------------------------------------------------------------------

// universalBlankReq

// optional string dayTime = 1;
inline bool universalBlankReq::has_daytime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void universalBlankReq::set_has_daytime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void universalBlankReq::clear_has_daytime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void universalBlankReq::clear_daytime() {
  daytime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_daytime();
}
inline const ::std::string& universalBlankReq::daytime() const {
  // @@protoc_insertion_point(field_get:bookCityService.universalBlankReq.dayTime)
  return daytime_.GetNoArena();
}
inline void universalBlankReq::set_daytime(const ::std::string& value) {
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.universalBlankReq.dayTime)
}
#if LANG_CXX11
inline void universalBlankReq::set_daytime(::std::string&& value) {
  set_has_daytime();
  daytime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.universalBlankReq.dayTime)
}
#endif
inline void universalBlankReq::set_daytime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.universalBlankReq.dayTime)
}
inline void universalBlankReq::set_daytime(const char* value, size_t size) {
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.universalBlankReq.dayTime)
}
inline ::std::string* universalBlankReq::mutable_daytime() {
  set_has_daytime();
  // @@protoc_insertion_point(field_mutable:bookCityService.universalBlankReq.dayTime)
  return daytime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* universalBlankReq::release_daytime() {
  // @@protoc_insertion_point(field_release:bookCityService.universalBlankReq.dayTime)
  if (!has_daytime()) {
    return NULL;
  }
  clear_has_daytime();
  return daytime_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void universalBlankReq::set_allocated_daytime(::std::string* daytime) {
  if (daytime != NULL) {
    set_has_daytime();
  } else {
    clear_has_daytime();
  }
  daytime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), daytime);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.universalBlankReq.dayTime)
}

// optional int32 count = 2;
inline bool universalBlankReq::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void universalBlankReq::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void universalBlankReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void universalBlankReq::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 universalBlankReq::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.universalBlankReq.count)
  return count_;
}
inline void universalBlankReq::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.universalBlankReq.count)
}

// -------------------------------------------------------------------

// mostlybooks

// required string bookId = 1;
inline bool mostlybooks::has_bookid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mostlybooks::set_has_bookid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mostlybooks::clear_has_bookid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mostlybooks::clear_bookid() {
  bookid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookid();
}
inline const ::std::string& mostlybooks::bookid() const {
  // @@protoc_insertion_point(field_get:bookCityService.mostlybooks.bookId)
  return bookid_.GetNoArena();
}
inline void mostlybooks::set_bookid(const ::std::string& value) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.mostlybooks.bookId)
}
#if LANG_CXX11
inline void mostlybooks::set_bookid(::std::string&& value) {
  set_has_bookid();
  bookid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.mostlybooks.bookId)
}
#endif
inline void mostlybooks::set_bookid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.mostlybooks.bookId)
}
inline void mostlybooks::set_bookid(const char* value, size_t size) {
  set_has_bookid();
  bookid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.mostlybooks.bookId)
}
inline ::std::string* mostlybooks::mutable_bookid() {
  set_has_bookid();
  // @@protoc_insertion_point(field_mutable:bookCityService.mostlybooks.bookId)
  return bookid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mostlybooks::release_bookid() {
  // @@protoc_insertion_point(field_release:bookCityService.mostlybooks.bookId)
  if (!has_bookid()) {
    return NULL;
  }
  clear_has_bookid();
  return bookid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mostlybooks::set_allocated_bookid(::std::string* bookid) {
  if (bookid != NULL) {
    set_has_bookid();
  } else {
    clear_has_bookid();
  }
  bookid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookid);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.mostlybooks.bookId)
}

// required string bookName = 2;
inline bool mostlybooks::has_bookname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mostlybooks::set_has_bookname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mostlybooks::clear_has_bookname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mostlybooks::clear_bookname() {
  bookname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bookname();
}
inline const ::std::string& mostlybooks::bookname() const {
  // @@protoc_insertion_point(field_get:bookCityService.mostlybooks.bookName)
  return bookname_.GetNoArena();
}
inline void mostlybooks::set_bookname(const ::std::string& value) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.mostlybooks.bookName)
}
#if LANG_CXX11
inline void mostlybooks::set_bookname(::std::string&& value) {
  set_has_bookname();
  bookname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.mostlybooks.bookName)
}
#endif
inline void mostlybooks::set_bookname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.mostlybooks.bookName)
}
inline void mostlybooks::set_bookname(const char* value, size_t size) {
  set_has_bookname();
  bookname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.mostlybooks.bookName)
}
inline ::std::string* mostlybooks::mutable_bookname() {
  set_has_bookname();
  // @@protoc_insertion_point(field_mutable:bookCityService.mostlybooks.bookName)
  return bookname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mostlybooks::release_bookname() {
  // @@protoc_insertion_point(field_release:bookCityService.mostlybooks.bookName)
  if (!has_bookname()) {
    return NULL;
  }
  clear_has_bookname();
  return bookname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mostlybooks::set_allocated_bookname(::std::string* bookname) {
  if (bookname != NULL) {
    set_has_bookname();
  } else {
    clear_has_bookname();
  }
  bookname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookname);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.mostlybooks.bookName)
}

// required int32 searchTimes = 3;
inline bool mostlybooks::has_searchtimes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mostlybooks::set_has_searchtimes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mostlybooks::clear_has_searchtimes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mostlybooks::clear_searchtimes() {
  searchtimes_ = 0;
  clear_has_searchtimes();
}
inline ::google::protobuf::int32 mostlybooks::searchtimes() const {
  // @@protoc_insertion_point(field_get:bookCityService.mostlybooks.searchTimes)
  return searchtimes_;
}
inline void mostlybooks::set_searchtimes(::google::protobuf::int32 value) {
  set_has_searchtimes();
  searchtimes_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.mostlybooks.searchTimes)
}

// -------------------------------------------------------------------

// mostlySearchRes

// repeated .bookCityService.mostlybooks lists = 1;
inline int mostlySearchRes::lists_size() const {
  return lists_.size();
}
inline void mostlySearchRes::clear_lists() {
  lists_.Clear();
}
inline ::bookCityService::mostlybooks* mostlySearchRes::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:bookCityService.mostlySearchRes.lists)
  return lists_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bookCityService::mostlybooks >*
mostlySearchRes::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:bookCityService.mostlySearchRes.lists)
  return &lists_;
}
inline const ::bookCityService::mostlybooks& mostlySearchRes::lists(int index) const {
  // @@protoc_insertion_point(field_get:bookCityService.mostlySearchRes.lists)
  return lists_.Get(index);
}
inline ::bookCityService::mostlybooks* mostlySearchRes::add_lists() {
  // @@protoc_insertion_point(field_add:bookCityService.mostlySearchRes.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bookCityService::mostlybooks >&
mostlySearchRes::lists() const {
  // @@protoc_insertion_point(field_list:bookCityService.mostlySearchRes.lists)
  return lists_;
}

// required int32 count = 2;
inline bool mostlySearchRes::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mostlySearchRes::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mostlySearchRes::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mostlySearchRes::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 mostlySearchRes::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.mostlySearchRes.count)
  return count_;
}
inline void mostlySearchRes::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.mostlySearchRes.count)
}

// -------------------------------------------------------------------

// fuzzySearchRequest

// required string words = 1;
inline bool fuzzySearchRequest::has_words() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fuzzySearchRequest::set_has_words() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fuzzySearchRequest::clear_has_words() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fuzzySearchRequest::clear_words() {
  words_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_words();
}
inline const ::std::string& fuzzySearchRequest::words() const {
  // @@protoc_insertion_point(field_get:bookCityService.fuzzySearchRequest.words)
  return words_.GetNoArena();
}
inline void fuzzySearchRequest::set_words(const ::std::string& value) {
  set_has_words();
  words_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.fuzzySearchRequest.words)
}
#if LANG_CXX11
inline void fuzzySearchRequest::set_words(::std::string&& value) {
  set_has_words();
  words_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.fuzzySearchRequest.words)
}
#endif
inline void fuzzySearchRequest::set_words(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_words();
  words_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.fuzzySearchRequest.words)
}
inline void fuzzySearchRequest::set_words(const char* value, size_t size) {
  set_has_words();
  words_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.fuzzySearchRequest.words)
}
inline ::std::string* fuzzySearchRequest::mutable_words() {
  set_has_words();
  // @@protoc_insertion_point(field_mutable:bookCityService.fuzzySearchRequest.words)
  return words_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* fuzzySearchRequest::release_words() {
  // @@protoc_insertion_point(field_release:bookCityService.fuzzySearchRequest.words)
  if (!has_words()) {
    return NULL;
  }
  clear_has_words();
  return words_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void fuzzySearchRequest::set_allocated_words(::std::string* words) {
  if (words != NULL) {
    set_has_words();
  } else {
    clear_has_words();
  }
  words_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), words);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.fuzzySearchRequest.words)
}

// required string dayTime = 2;
inline bool fuzzySearchRequest::has_daytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fuzzySearchRequest::set_has_daytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fuzzySearchRequest::clear_has_daytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fuzzySearchRequest::clear_daytime() {
  daytime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_daytime();
}
inline const ::std::string& fuzzySearchRequest::daytime() const {
  // @@protoc_insertion_point(field_get:bookCityService.fuzzySearchRequest.dayTime)
  return daytime_.GetNoArena();
}
inline void fuzzySearchRequest::set_daytime(const ::std::string& value) {
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bookCityService.fuzzySearchRequest.dayTime)
}
#if LANG_CXX11
inline void fuzzySearchRequest::set_daytime(::std::string&& value) {
  set_has_daytime();
  daytime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bookCityService.fuzzySearchRequest.dayTime)
}
#endif
inline void fuzzySearchRequest::set_daytime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bookCityService.fuzzySearchRequest.dayTime)
}
inline void fuzzySearchRequest::set_daytime(const char* value, size_t size) {
  set_has_daytime();
  daytime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bookCityService.fuzzySearchRequest.dayTime)
}
inline ::std::string* fuzzySearchRequest::mutable_daytime() {
  set_has_daytime();
  // @@protoc_insertion_point(field_mutable:bookCityService.fuzzySearchRequest.dayTime)
  return daytime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* fuzzySearchRequest::release_daytime() {
  // @@protoc_insertion_point(field_release:bookCityService.fuzzySearchRequest.dayTime)
  if (!has_daytime()) {
    return NULL;
  }
  clear_has_daytime();
  return daytime_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void fuzzySearchRequest::set_allocated_daytime(::std::string* daytime) {
  if (daytime != NULL) {
    set_has_daytime();
  } else {
    clear_has_daytime();
  }
  daytime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), daytime);
  // @@protoc_insertion_point(field_set_allocated:bookCityService.fuzzySearchRequest.dayTime)
}

// required int32 count = 3;
inline bool fuzzySearchRequest::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fuzzySearchRequest::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fuzzySearchRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fuzzySearchRequest::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 fuzzySearchRequest::count() const {
  // @@protoc_insertion_point(field_get:bookCityService.fuzzySearchRequest.count)
  return count_;
}
inline void fuzzySearchRequest::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.fuzzySearchRequest.count)
}

// required int32 offset = 4;
inline bool fuzzySearchRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fuzzySearchRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fuzzySearchRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fuzzySearchRequest::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 fuzzySearchRequest::offset() const {
  // @@protoc_insertion_point(field_get:bookCityService.fuzzySearchRequest.offset)
  return offset_;
}
inline void fuzzySearchRequest::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bookCityService.fuzzySearchRequest.offset)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bookCityService

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_bookcity_2eproto
